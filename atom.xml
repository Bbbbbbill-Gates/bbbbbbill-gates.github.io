<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>好喜欢胖鱼啊啊啊啊啊啊啊</title>
  
  <subtitle>Coding changes the world</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.anjinyang.top/"/>
  <updated>2019-10-16T03:04:09.830Z</updated>
  <id>https://www.anjinyang.top/</id>
  
  <author>
    <name>ajy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hello</title>
    <link href="https://www.anjinyang.top/2019/10/16/hello/"/>
    <id>https://www.anjinyang.top/2019/10/16/hello/</id>
    <published>2019-10-16T02:34:56.000Z</published>
    <updated>2019-10-16T03:04:09.830Z</updated>
    
    <content type="html"><![CDATA[<p>你好，这是一篇测试文章。</p> <a id="more"></a> <p><img src="/2019/10/16/hello/testPic.jpg" alt="testPic"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你好，这是一篇测试文章。&lt;/p&gt;
    
    </summary>
    
    
      <category term="test" scheme="https://www.anjinyang.top/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://www.anjinyang.top/2019/10/15/hello-world/"/>
    <id>https://www.anjinyang.top/2019/10/15/hello-world/</id>
    <published>2019-10-15T12:21:30.957Z</published>
    <updated>2019-10-16T03:05:50.407Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>. <a id="more"></a> </p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前缀和差分专题</title>
    <link href="https://www.anjinyang.top/2019/06/02/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    <id>https://www.anjinyang.top/2019/06/02/前缀和/</id>
    <published>2019-06-02T01:43:01.000Z</published>
    <updated>2019-10-16T03:04:57.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="激光炸弹"><a href="#激光炸弹" class="headerlink" title="激光炸弹"></a>激光炸弹</h1><p>一种新型的激光炸弹，可以摧毁一个边长为 R 的正方形内的所有的目标。</p><p>现在地图上有 N 个目标，用整数Xi,Yi表示目标在地图上的位置，每个目标都有一个价值Wi。 <a id="more"></a> </p><p>激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个边长为 R 的正方形的边必须和x，y轴平行。</p><p>若目标位于爆破正方形的边上，该目标不会被摧毁。</p><p>求一颗炸弹最多能炸掉地图上总价值为多少的目标。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入正整数 N 和 R ,分别代表地图上的目标数目和正方形的边长，数据用空格隔开。</p><p>接下来N行，每行输入一组数据，每组数据包括三个整数Xi,Yi,Wi,分别代表目标的x坐标，y坐标和价值，数据用空格隔开。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N≤10000,0≤Xi,Yi≤5000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">0 0 1</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>分析：前缀和以o(1)的复杂度快速求得指定区间的和。本题为二维前缀和。一维前缀和见士兵杀敌。一维，s[i]=a[0]+a[1]+…+a[i]；二维，g [i]·[j]=左上角矩阵的和。二维通常下标从1开始，不需要处理边界。大数组定义在静态区，不会爆。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5005</span>;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,r,x,y,w;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;r;</span><br><span class="line"><span class="keyword">int</span> mx=r,my=r;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">x++,y++;</span><br><span class="line">mx=max(mx,x),my=max(my,y);</span><br><span class="line">g[x][y]+=w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mx;i++)<span class="comment">//求二维前缀和</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=my;j++)</span><br><span class="line">g[i][j]+=g[i<span class="number">-1</span>][j]+g[i][j<span class="number">-1</span>]-g[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=r;i&lt;=mx;i++)<span class="comment">//题意要求边长为r的矩阵，由二维前缀和画图可推导公式。以g[i][j]为右下角的边长为r的矩阵（不包括边界，即不包括左边界和上边界）的总价值算法为：g[i][j]-g[i-r][j]-g[i][j-r]+g[i-r][j-r]。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=r;j&lt;=my;j++)</span><br><span class="line">ans=max(ans,g[i][j]-g[i-r][j]-g[i][j-r]+g[i-r][j-r]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="IncDec序列"><a href="#IncDec序列" class="headerlink" title="IncDec序列"></a>IncDec序列</h1><p>给定一个长度为 n 的数列 a1,a2,…,an，每次可以选择一个区间 [l,r]，使下标在这个区间内的数都加一或者都减一。</p><p>求至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列可能有多少种。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入正整数n。</p><p>接下来n行，每行输入一个整数，第i+1行的整数代表ai。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>第一行输出最少操作次数。</p><p>第二行输出最终能得到多少种结果。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p> 0&lt;n≤10^5,0≤ai&lt;2147483648</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>分析：做前缀和的逆运算，即差分。b[i]=a[i]-a[i-1]，则b为a的差分；可得a[i]=b[1]+……+b[i]，故a为b的前缀和。差分的性质，也就是把序列A的区间[L,R]加d，也就是把A[l],A[l+1]….A[r]都加上d，其实就是它的差分序列B中，B[l]+d,B[r+1]−d，其他的位置统统不改变。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">ll a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//做差分的时候要考虑i=1的时候 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">b[i]=a[i]-a[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for(int i=n;i&gt;1;i--)a[i]-=a[i-1];</span></span><br><span class="line"></span><br><span class="line">ll pos=<span class="number">0</span>,neg=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(b[i]&gt;<span class="number">0</span>)pos+=b[i];</span><br><span class="line"><span class="keyword">else</span> neg-=b[i];<span class="comment">//因为是负数，要想neg是正数需要用减号。 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;min(pos,neg)+<span class="built_in">abs</span>(pos-neg)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">abs</span>(pos-neg)+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*//稍微精简的写法</span></span><br><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">using namespace std;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">typedef long long ll;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">const int N=1e5+5;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">ll a[N];</span></span><br><span class="line"><span class="comment">int main()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">int n;</span></span><br><span class="line"><span class="comment">cin&gt;&gt;n;</span></span><br><span class="line"><span class="comment">for(int i=1;i&lt;=n;i++)//做差分的时候要考虑i=1的时候 </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cin&gt;&gt;a[i];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">for(int i=n;i&gt;1;i--)a[i]-=a[i-1];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">ll pos=0,neg=0;</span></span><br><span class="line"><span class="comment">for(int i=2;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">if(b[i]&gt;0)pos+=a[i];</span></span><br><span class="line"><span class="comment">else neg-=a[i];//因为是负数，要想neg是正数需要用减号。 </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">cout&lt;&lt;min(pos,neg)+abs(pos-neg)&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">cout&lt;&lt;abs(pos-neg)+1&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">return 0;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br></pre></td></tr></table></figure><h1 id="最高的牛"><a href="#最高的牛" class="headerlink" title="最高的牛"></a>最高的牛</h1><p>有 N 头牛站成一行，被编队为1、2、3…N，每头牛的身高都为整数。</p><p>当且仅当两头牛中间的牛身高都比它们矮时，两头牛方可看到对方。</p><p>现在，我们只知道其中最高的牛是第 P 头，它的身高是 H ，剩余牛的身高未知。</p><p>但是，我们还知道这群牛之中存在着 M 对关系，每对关系都指明了某两头牛 A 和 B 可以相互看见。</p><p>求每头牛的身高的最大可能值是多少。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入整数 N,P,H,M，数据用空格隔开。</p><p>接下来M行，每行输出两个整数 A 和 B ，代表牛 A 和牛 B 可以相互看见，数据用空格隔开。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>一共输出 N 行数据，每行输出一个整数。</p><p>第 i 行输出的整数代表第 i 头牛可能的最大身高。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤10000,1≤H≤1000000,1≤A,B≤10000,0≤M≤10000</p><p>分析：典型差分问题，问题的最后还结合了差分向前缀和的转化。问题关键点在于如何转化为差分模型，该题提供的关系不可能交叉，所以关系就可以看做差分要操作的区间，最高的牛的高度表明所有的高度都小于等于H，即差分数列的首项为H。在接受关系的过程中，存在判重问题，即同一对关系出现多次无用，再次出现时不可以再对该区间做相同操作（因为要求最高，出现一次，区间内所有高度减一，若再次出现，正确答案不为减二。）</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判重部分涉及：1.set&lt;pair&lt;int,int&gt;&gt;existed;2.map&lt;pair&lt;int,int&gt;,bool&gt;existed;(前者略快？map a=b也可以？)3.unordered_set(希)set&lt;int&gt;existed;4.boolexisted[10010],if(!existed[a])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> height[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,p,h,m;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p&gt;&gt;h&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">height[<span class="number">1</span>]=h;<span class="comment">//把height看做差分数列</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; existed;<span class="comment">//这部分实现关系判重接受和区间操作</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,a,b;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="comment">//自己写落了判ab大小</span></span><br><span class="line"><span class="keyword">if</span>(a&gt;b)swap(a,b); </span><br><span class="line"><span class="keyword">if</span>(!existed.count(&#123;a,b&#125;))</span><br><span class="line">&#123;</span><br><span class="line">existed.insert(&#123;a,b&#125;);</span><br><span class="line">height[a+<span class="number">1</span>]--,height[b]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//差分转化为前缀和</span></span><br><span class="line">&#123;</span><br><span class="line">height[i]+=height[i<span class="number">-1</span>];</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;height[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;激光炸弹&quot;&gt;&lt;a href=&quot;#激光炸弹&quot; class=&quot;headerlink&quot; title=&quot;激光炸弹&quot;&gt;&lt;/a&gt;激光炸弹&lt;/h1&gt;&lt;p&gt;一种新型的激光炸弹，可以摧毁一个边长为 R 的正方形内的所有的目标。&lt;/p&gt;
&lt;p&gt;现在地图上有 N 个目标，用整数Xi,Yi表示目标在地图上的位置，每个目标都有一个价值Wi。&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://www.anjinyang.top/tags/algorithm/"/>
    
      <category term="基础算法" scheme="https://www.anjinyang.top/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
      <category term="前缀和" scheme="https://www.anjinyang.top/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="差分" scheme="https://www.anjinyang.top/tags/%E5%B7%AE%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯真题-密文搜索</title>
    <link href="https://www.anjinyang.top/2019/06/02/%E5%AF%86%E6%96%87%E6%90%9C%E7%B4%A2%E8%93%9D%E6%A1%A5/"/>
    <id>https://www.anjinyang.top/2019/06/02/密文搜索蓝桥/</id>
    <published>2019-06-02T01:43:01.000Z</published>
    <updated>2019-10-16T03:04:48.652Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>福尔摩斯从X星收到一份资料，全部是小写字母组成。他的助手提供了另一份资料：许多长度为8的密码列表。福尔摩斯发现，这些密码是被打乱后隐藏在先前那份资料中的。</p><p>请你编写一个程序，从第一份资料中搜索可能隐藏密码的位置。要考虑密码的所有排列 <a id="more"></a> 可能性。</p><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><p>输入第一行：一个字符串s，全部由小写字母组成，长度小于1024*1024<br>紧接着一行是一个整数n,表示以下有n行密码，1&lt;=n&lt;=1000<br>紧接着是n行字符串，都是小写字母组成，长度都为8</p><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><p>一个整数, 表示每行密码的所有排列在s中匹配次数的总和。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aaaabbbbaabbcccc</span><br><span class="line">2</span><br><span class="line">aaaabbbb</span><br><span class="line">abcabccc</span><br></pre></td></tr></table></figure><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">string</span> s1;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; maps;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s&gt;&gt;n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len=s.length();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+<span class="number">7</span>&lt;len;i++)<span class="comment">//i+8错误，应为i+7 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+<span class="number">8</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line">temp+=s[j];</span><br><span class="line">sort(temp.begin(),temp.end());</span><br><span class="line">maps[temp]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s1;</span><br><span class="line">sort(s1.begin(),s1.end());</span><br><span class="line"><span class="comment">//if(maps.count(s1))ans++;</span></span><br><span class="line"><span class="keyword">if</span>(maps.count(s1))ans+=maps[s1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h3&gt;&lt;p&gt;福尔摩斯从X星收到一份资料，全部是小写字母组成。他的助手提供了另一份资料：许多长度为8的密码列表。福尔摩斯发现，这些密码是被打乱后隐藏在先前那份资料中的。&lt;/p&gt;
&lt;p&gt;请你编写一个程序，从第一份资料中搜索可能隐藏密码的位置。要考虑密码的所有排列&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://www.anjinyang.top/tags/algorithm/"/>
    
      <category term="基础算法" scheme="https://www.anjinyang.top/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
      <category term="stl" scheme="https://www.anjinyang.top/tags/stl/"/>
    
      <category term="蓝桥" scheme="https://www.anjinyang.top/tags/%E8%93%9D%E6%A1%A5/"/>
    
  </entry>
  
  <entry>
    <title>博弈论专题</title>
    <link href="https://www.anjinyang.top/2019/06/02/%E5%8D%9A%E5%BC%88%E8%AE%BA%E4%B8%93%E9%A2%98/"/>
    <id>https://www.anjinyang.top/2019/06/02/博弈论专题/</id>
    <published>2019-06-02T01:43:01.000Z</published>
    <updated>2019-10-16T03:04:22.002Z</updated>
    
    <content type="html"><![CDATA[<h3 id="巴什博奕"><a href="#巴什博奕" class="headerlink" title="巴什博奕"></a>巴什博奕</h3><p>两个人，n个石子，每次可以取1-m个石子，不能拿的人失败，另一个人胜利</p><ul><li>1 &lt;= 石子数量 &lt;= m 时，先手必胜</li><li>m + 1 = 石子数量 时，先手必败</li><li>m + 2 &lt;= 石子数量 &lt;= 2 * m 时，先手可以让石子数量变为 m + 1 先手必胜</li></ul><p>推广可得 <a id="more"></a> </p><ul><li>当n = k * (m + 1) + r</li></ul><p>先手拿走r个，每次都可以让另一个人面对k * (m + 1)的棋局，直到k = 1。所以先手必胜</p><ul><li>当n = k * (m + 1)</li></ul><p>无论先手拿几个，后手每次都可以让先手面对k * (m + 1)的棋局，直到k = 1。所以先手必败</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">if</span>(n % (m + <span class="number">1</span>) == <span class="number">0</span>)<span class="built_in">cout</span> &lt;&lt; <span class="string">"second"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"first"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="斐波那契博奕"><a href="#斐波那契博奕" class="headerlink" title="斐波那契博奕"></a>斐波那契博奕</h3><p>一堆石子，先取者可以任意取，但是不能取完，以后每个人取得石子数都不能超过上个人的两倍</p><p>先手必败，当且仅当石子数为斐波那契数时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> feb[<span class="number">100</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">100</span>; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        feb[i] = feb[i - <span class="number">1</span>]+feb[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; feb[100] &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(binary_search(feb,feb + <span class="number">100</span>,n))<span class="built_in">cout</span> &lt;&lt; <span class="string">"Second win"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"First win"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="威佐夫博弈"><a href="#威佐夫博弈" class="headerlink" title="威佐夫博弈"></a>威佐夫博弈</h3><p>有两堆石子，每次可以从一堆石子中取任意多的石子，或者从两堆石子中取同样多的石子，不能取的人输</p><p>两堆石子（x , y）(x &lt; y)，先手必败，当且仅当<br>$$<br>（y - x）\times(1+\sqrt{5})\div2=x<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> t=(<span class="number">1.0</span>+<span class="built_in">sqrt</span>(<span class="number">5</span>))/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &lt; a)swap(a,b);</span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">int</span>)((b - a) * t) == a)<span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尼姆博奕"><a href="#尼姆博奕" class="headerlink" title="尼姆博奕"></a>尼姆博奕</h3><p>有n堆石子，两个人可以从任意一堆石子中拿任意多个石子（不能不拿），没法拿的失败</p><p>当n堆石子数量异或和为0时，先手必败。</p><p>当n堆石子数量异或和不为0，可以某一个数减去n-1堆石子数量异或和，先手必胜。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans,cnt,arr[N],m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; m &amp;&amp; m)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">            ans ^= arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="number">0</span>)<span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m; ++ i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t = ans ^ arr[i];<span class="comment">//求n-1堆石子的异或和，一个数字被异或和两次，相当于没有参加运算。一个数异或2次得0,0异或任何值都为它本身</span></span><br><span class="line">                <span class="keyword">if</span>(arr[i] &gt;= t)cnt ++ ;<span class="comment">//如果可以减，方案加一</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;巴什博奕&quot;&gt;&lt;a href=&quot;#巴什博奕&quot; class=&quot;headerlink&quot; title=&quot;巴什博奕&quot;&gt;&lt;/a&gt;巴什博奕&lt;/h3&gt;&lt;p&gt;两个人，n个石子，每次可以取1-m个石子，不能拿的人失败，另一个人胜利&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= 石子数量 &amp;lt;= m 时，先手必胜&lt;/li&gt;
&lt;li&gt;m + 1 = 石子数量 时，先手必败&lt;/li&gt;
&lt;li&gt;m + 2 &amp;lt;= 石子数量 &amp;lt;= 2 * m 时，先手可以让石子数量变为 m + 1 先手必胜&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;推广可得&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://www.anjinyang.top/tags/algorithm/"/>
    
      <category term="基础算法" scheme="https://www.anjinyang.top/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
      <category term="博弈论" scheme="https://www.anjinyang.top/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>牛客网-小a与星际探索</title>
    <link href="https://www.anjinyang.top/2019/06/02/%E5%B0%8Fa%E4%B8%8E%E6%98%9F%E9%99%85%E6%8E%A2%E7%B4%A2vector%E5%90%91%E9%87%8F/"/>
    <id>https://www.anjinyang.top/2019/06/02/小a与星际探索vector向量/</id>
    <published>2019-06-02T01:43:01.000Z</published>
    <updated>2019-10-16T03:05:32.890Z</updated>
    
    <content type="html"><![CDATA[<h1 id="小a与星际探索"><a href="#小a与星际探索" class="headerlink" title="小a与星际探索"></a>小a与星际探索</h1><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>链接：</p><p><a href="https://ac.nowcoder.com/acm/contest/317/C" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/317/C</a></p><p>来源：牛客网</p><p>小a正在玩一款星际探索游戏，小a需要驾驶着飞船从1号星球出发前往n号星球。其中每个星球有一个能量指数pi。星球i 能到达 星球j 当且仅当pi&gt;pj。同时小a的飞船还有一个耐久度t，初始时为1号点的能量指数，若小a前往星球j，那么飞船的耐久度会变为t⊕pj(即t异或pj，关于其定义请自行百度)小a想知道到达n号星球时耐久度最大为多少。注意：对于每个位置来说，从它出发可以到达的位置仅与两者的能量指数p有关，与下标无关。 <a id="more"></a> </p><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行一个整数n，表示星球数</span><br><span class="line">接下来一行有n个整数，第i个整数表示pi</span><br></pre></td></tr></table></figure><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个整数表示到达n号星球时最大的耐久度</span><br><span class="line">若不能到达n号星球或到达时的最大耐久度为0则输出−1</span><br></pre></td></tr></table></figure><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">小a有两种方法到达3号星球</span><br><span class="line">第一种：</span><br><span class="line">1→2→3，最终耐久度为457⊕456⊕23=22</span><br><span class="line">第二种：</span><br><span class="line">1→3，最终耐久度为457⊕23=478</span><br><span class="line"></span><br><span class="line">1⩽n,∀pi⩽3000</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3005</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,p[N];<span class="comment">//求异或最大（本题只能异或比自己当前异或的数小的数，不影响异或选出来的所有的数。）上三角矩阵，最大独立集（任何一个数不能被其他的数异或出来），求法高斯消元。 </span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">cin</span>&gt;&gt;p[i];</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)<span class="built_in">cout</span>&lt;&lt;(p[<span class="number">0</span>]?p[<span class="number">0</span>]:<span class="number">-1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(p[<span class="number">0</span>]&lt;=p[n<span class="number">-1</span>])<span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;sets;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p[i]&lt;p[<span class="number">0</span>]&amp;&amp;p[i]&gt;p[n<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line">sets.push_back(p[i]);<span class="comment">//因为只能到达比当前星球能量指数小的星球，初始星球能量指数为p[0]，最终要求到第n个星球（能量指数为p[n-1]），所以中间的星球能量指数一定在p[0]到p[n-1]之间。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sets.size())<span class="comment">//这里高斯消元的过程。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">14</span>,k=<span class="number">0</span>;i&gt;=<span class="number">0</span>;i--)<span class="comment">//寻找第I位为1的数，让其下标为K； </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=k;j&lt;sets.size();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(sets[j]&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">swap(sets[j],sets[k]);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sets[k]&gt;&gt;i&amp;<span class="number">1</span>)<span class="comment">//检查后面的数，如果该位上也为1，则让其变为0 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=k+<span class="number">1</span>;j&lt;sets.size();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(sets[j]&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sets[j]^=sets[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res=p[<span class="number">0</span>]^p[n<span class="number">-1</span>];<span class="comment">//答案肯定包括第一个能量和最后一个能量。</span></span><br><span class="line"><span class="keyword">if</span>(sets.size())<span class="comment">//扫一遍求答案即可。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">14</span>,k=<span class="number">0</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(sets[k]&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!(res&gt;&gt;i&amp;<span class="number">1</span>))res^=sets[k]; </span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!res)res=<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;小a与星际探索&quot;&gt;&lt;a href=&quot;#小a与星际探索&quot; class=&quot;headerlink&quot; title=&quot;小a与星际探索&quot;&gt;&lt;/a&gt;小a与星际探索&lt;/h1&gt;&lt;h3 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h3&gt;&lt;p&gt;链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/317/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/contest/317/C&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来源：牛客网&lt;/p&gt;
&lt;p&gt;小a正在玩一款星际探索游戏，小a需要驾驶着飞船从1号星球出发前往n号星球。其中每个星球有一个能量指数pi。星球i 能到达 星球j 当且仅当pi&amp;gt;pj。同时小a的飞船还有一个耐久度t，初始时为1号点的能量指数，若小a前往星球j，那么飞船的耐久度会变为t⊕pj(即t异或pj，关于其定义请自行百度)小a想知道到达n号星球时耐久度最大为多少。注意：对于每个位置来说，从它出发可以到达的位置仅与两者的能量指数p有关，与下标无关。&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://www.anjinyang.top/tags/algorithm/"/>
    
      <category term="数论" scheme="https://www.anjinyang.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="高斯消元" scheme="https://www.anjinyang.top/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"/>
    
      <category term="矩阵" scheme="https://www.anjinyang.top/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>牛客网-小a与轰炸游戏</title>
    <link href="https://www.anjinyang.top/2019/06/02/%E5%B0%8Fa%E4%B8%8E%E8%BD%B0%E7%82%B8%E6%B8%B8%E6%88%8F/"/>
    <id>https://www.anjinyang.top/2019/06/02/小a与轰炸游戏/</id>
    <published>2019-06-02T01:43:01.000Z</published>
    <updated>2019-10-16T03:05:18.506Z</updated>
    
    <content type="html"><![CDATA[<h1 id="小a与轰炸游戏"><a href="#小a与轰炸游戏" class="headerlink" title="小a与轰炸游戏"></a>小a与轰炸游戏</h1><p>链接：</p><p><a href="https://ac.nowcoder.com/acm/contest/317/E" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/317/E</a></p><p>来源：牛客网</p><p>小a正在玩一款即时战略游戏，现在他要用航空母舰对敌方阵地进行轰炸<br> 地方阵地可以看做是n×m的矩形<br> 航空母舰总共会派出q架飞机。<br> 飞机有两种，第一种飞机会轰炸以(xi,yi)为中心，对角线长为li的正菱形(也就是两条对角线分别于x轴 y轴平行的正方形)，而第二种飞机只会轰炸正菱形的上半部分(包括第xi行)<br> (具体看样例解释) <a id="more"></a><br> 现在小a想知道所有格子被轰炸次数的异或和<br> 注意：不保证被轰炸的格子一定在矩形范围内，若越界请忽略</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行三个整数n,m,q，分别表示矩阵的长/宽/询问次数</span><br><span class="line">接下来q行，每行四个整数opt,x,y,l，表示飞机类型，轰炸的坐标，以及对角线长度</span><br><span class="line">保证l为奇数！</span><br></pre></td></tr></table></figure><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个整数，表示所有格子被轰炸次数的异或和</span><br></pre></td></tr></table></figure><p>分析：二维差分，更复杂了，分四个方向需要一开始就想到。写代码难点在up、down函数的下标和计算答案时候考虑到取什么范围的数。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3005</span>,L=<span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N][N],b[N][N],c[N][N],d[N][N];<span class="comment">//用4个方向的差分避免了互相影响，如果在一个数组可能会让不同的数据之间抵消。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> l)</span><span class="comment">//up down里面的下标特比容易写错</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a[x-l/<span class="number">2</span>][y]++,b[x-l/<span class="number">2</span>][y+<span class="number">1</span>]--;</span><br><span class="line">a[x+<span class="number">1</span>][y-l/<span class="number">2</span><span class="number">-1</span>]--;b[x+<span class="number">1</span>][y+l/<span class="number">2</span>+<span class="number">2</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">c[x+<span class="number">1</span>][y-l/<span class="number">2</span>+<span class="number">1</span>]++,d[x+<span class="number">1</span>][y+l/<span class="number">2</span>]--;</span><br><span class="line">c[x+l/<span class="number">2</span>+<span class="number">1</span>][y+<span class="number">1</span>]--,d[x+l/<span class="number">2</span>+<span class="number">1</span>][y]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m,q;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,opt,x,y,l;i&lt;q;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;opt,&amp;x,&amp;y,&amp;l);</span><br><span class="line">x+=L,y+=L;<span class="comment">//偏移做法，中间为1000*1000的正方形，最后计算答案的时候计算从L+1到L+n行，L+1列到L+m列。</span></span><br><span class="line">up(x,y,l);</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="number">1</span>) down(x,y,l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=L*<span class="number">2</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;L*<span class="number">2</span>+m;j++)</span><br><span class="line">&#123;</span><br><span class="line">t+=a[i][j]+b[i][j]+c[i][j]+d[i][j];<span class="comment">//这里由差分数列求前缀和，和即为轰炸的次数。</span></span><br><span class="line"><span class="keyword">if</span>(i&gt;=L+<span class="number">1</span>&amp;&amp;i&lt;=L+n&amp;&amp;j&gt;=L+<span class="number">1</span>&amp;&amp;j&lt;=L+m)ans^=t;</span><br><span class="line">a[i+<span class="number">1</span>][j<span class="number">-1</span>]+=a[i][j];<span class="comment">//因为差分数列通过改变开头和结尾两个数达到改变整个数组的目的，所以在计算完一部分之后，为了不再重复回到上面计算，这里直接做顺延操作，避免了重复操作。</span></span><br><span class="line">b[i+<span class="number">1</span>][j+<span class="number">1</span>]+=b[i][j];</span><br><span class="line">c[i+<span class="number">1</span>][j+<span class="number">1</span>]+=c[i][j];</span><br><span class="line">d[i+<span class="number">1</span>][j<span class="number">-1</span>]+=d[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;小a与轰炸游戏&quot;&gt;&lt;a href=&quot;#小a与轰炸游戏&quot; class=&quot;headerlink&quot; title=&quot;小a与轰炸游戏&quot;&gt;&lt;/a&gt;小a与轰炸游戏&lt;/h1&gt;&lt;p&gt;链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/317/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/contest/317/E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来源：牛客网&lt;/p&gt;
&lt;p&gt;小a正在玩一款即时战略游戏，现在他要用航空母舰对敌方阵地进行轰炸&lt;br&gt; 地方阵地可以看做是n×m的矩形&lt;br&gt; 航空母舰总共会派出q架飞机。&lt;br&gt; 飞机有两种，第一种飞机会轰炸以(xi,yi)为中心，对角线长为li的正菱形(也就是两条对角线分别于x轴 y轴平行的正方形)，而第二种飞机只会轰炸正菱形的上半部分(包括第xi行)&lt;br&gt; (具体看样例解释)&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://www.anjinyang.top/tags/algorithm/"/>
    
      <category term="基础算法" scheme="https://www.anjinyang.top/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
      <category term="差分" scheme="https://www.anjinyang.top/tags/%E5%B7%AE%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>牛客网-小a与黄金街道</title>
    <link href="https://www.anjinyang.top/2019/06/02/%E5%B0%8Fa%E4%B8%8E%E9%BB%84%E9%87%91%E8%A1%97%E9%81%93%E6%AC%A7%E6%8B%89%E6%95%B0%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <id>https://www.anjinyang.top/2019/06/02/小a与黄金街道欧拉数与快速幂/</id>
    <published>2019-06-02T01:43:01.000Z</published>
    <updated>2019-10-16T03:05:26.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="小a与黄金街道"><a href="#小a与黄金街道" class="headerlink" title="小a与黄金街道"></a>小a与黄金街道</h1><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>题目连接：<a href="https://ac.nowcoder.com/acm/contest/317/D" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/317/D</a></p><p>小a和小b来到了一条布满了黄金的街道上。它们想要带几块黄金回去，然而这里的城管担心他们拿走的太多，于是要求小a和小b通过做一个游戏来决定最后得到的黄金的数量。 <a id="more"></a><br>游戏规则是这样的：<br>假设道路长度为n米(左端点为0，右端点为n)，同时给出一个数k(下面会提到k的用法)设小a初始时的黄金数量为A，小b初始时的黄金数量为B。小a从1出发走向n−1，小b从n−1出发走向1，两人的速度均为1m/s。假设某一时刻(必须为整数)小a的位置为x，小b的位置为y，若gcd(n,x)=1且gcd(n,y)=1，那么小a的黄金数量A会变为A∗k^x(kg)，小b的黄金数量B会变为B∗k^y(kg)，当小a到达n−1时游戏结束小a想知道在游戏结束时A+B的值，答案对10^9+7取模。</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一行四个整数n,k,A,B</span><br></pre></td></tr></table></figure><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出一个整数表示答案</span><br></pre></td></tr></table></figure><h3 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">保证3⩽n⩽ 10^8,1⩽A,B,k⩽ 10^13</span><br></pre></td></tr></table></figure><p>分析：这道题考察了欧拉数和快速幂。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LL X=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">quickpower</span><span class="params">(LL k,LL sum)</span><span class="comment">//快速幂模板</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(sum)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(sum&amp;<span class="number">1</span>)res=res*k%X;</span><br><span class="line">k=k*k%X;</span><br><span class="line">sum&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL n,k,a,b;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k&gt;&gt;a&gt;&gt;b;</span><br><span class="line">LL sum=n,euler=n;</span><br><span class="line"><span class="keyword">for</span>(LL p=<span class="number">2</span>;p*p&lt;=n;p++)<span class="comment">//欧拉数求法，euler=n*(1-1/a)*(1-1/b)···即，数n的欧拉数为：n乘所有的n的因子的倒数被一减去的差。欧拉数的含义：1-n所有与n互质的数的个数。一定为偶数，因为n/2与n不互质（n=2的情况特殊但也符合偶数）。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n%p==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">euler=euler/p*(p<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">while</span>(n%p==<span class="number">0</span>)n/=p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n&gt;<span class="number">1</span>)euler=euler/n*(n<span class="number">-1</span>);</span><br><span class="line">sum=sum*euler/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(a+b)*quickpower(k,sum)%X&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;小a与黄金街道&quot;&gt;&lt;a href=&quot;#小a与黄金街道&quot; class=&quot;headerlink&quot; title=&quot;小a与黄金街道&quot;&gt;&lt;/a&gt;小a与黄金街道&lt;/h1&gt;&lt;h3 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h3&gt;&lt;p&gt;题目连接：&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/317/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/contest/317/D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;小a和小b来到了一条布满了黄金的街道上。它们想要带几块黄金回去，然而这里的城管担心他们拿走的太多，于是要求小a和小b通过做一个游戏来决定最后得到的黄金的数量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://www.anjinyang.top/tags/algorithm/"/>
    
      <category term="数论" scheme="https://www.anjinyang.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="欧拉数" scheme="https://www.anjinyang.top/tags/%E6%AC%A7%E6%8B%89%E6%95%B0/"/>
    
      <category term="快速幂" scheme="https://www.anjinyang.top/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>搜索专题</title>
    <link href="https://www.anjinyang.top/2019/06/02/%E6%90%9C%E7%B4%A2%E4%B8%93%E9%A2%98/"/>
    <id>https://www.anjinyang.top/2019/06/02/搜索专题/</id>
    <published>2019-06-02T01:43:01.000Z</published>
    <updated>2019-10-16T03:05:01.090Z</updated>
    
    <content type="html"><![CDATA[<h2 id="棋盘问题"><a href="#棋盘问题" class="headerlink" title="棋盘问题"></a>棋盘问题</h2><p> 在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。 <a id="more"></a> </p><p>Input</p><p>输入含有多组测试数据。<br>每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n<br>当为-1 -1时表示输入结束。<br>随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。 </p><p>Output</p><p>对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">#.</span><br><span class="line">.#</span><br><span class="line">4 4</span><br><span class="line">...#</span><br><span class="line">..#.</span><br><span class="line">.#..</span><br><span class="line">#...</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">int</span> mp[N][N];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">bool</span> col[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(col,<span class="literal">true</span>,<span class="keyword">sizeof</span> col);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> ro,<span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt;ro &lt;&lt; " ro    " &lt;&lt; n &lt;&lt; " n    " &lt;&lt; cnt &lt;&lt; " cnt    " &lt;&lt; k &lt;&lt; " k" &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span>(cnt == k)</span><br><span class="line">    &#123;</span><br><span class="line">        ans ++;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ro == n)<span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*for(int i = 0;i &lt; n; ++ i)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if(! col[i] || mp[ro][i] == 1)continue;</span></span><br><span class="line"><span class="comment">        else</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            //cout &lt;&lt; ro &lt;&lt; " " &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">            dfs(ro + 1,cnt);</span></span><br><span class="line"><span class="comment">            col[i] = false;</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            dfs(ro + 1, cnt + 1);</span></span><br><span class="line"><span class="comment">            col[i] = true;</span></span><br><span class="line"><span class="comment">        &#125;//c&lt;=2^31 这个递归空间很大，逐个遍历所有空间所以浪费时间，应该想办法省去不选的递归空间</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = ro;i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(! col[j] || mp[i][j] == <span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; ro &lt;&lt; " " &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">                col[j] = <span class="literal">false</span>;</span><br><span class="line">                </span><br><span class="line">                dfs(i + <span class="number">1</span>, cnt + <span class="number">1</span>);</span><br><span class="line">                col[j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">-1</span> &amp;&amp; k == <span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        getchar();</span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n; ++ j)</span><br><span class="line">            &#123;</span><br><span class="line">                c=getchar();</span><br><span class="line">                <span class="comment">//cout &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">if</span>(c == <span class="string">'#'</span>)mp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> mp[i][j] = <span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            getchar();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;棋盘问题&quot;&gt;&lt;a href=&quot;#棋盘问题&quot; class=&quot;headerlink&quot; title=&quot;棋盘问题&quot;&gt;&lt;/a&gt;棋盘问题&lt;/h2&gt;&lt;p&gt; 在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://www.anjinyang.top/tags/algorithm/"/>
    
      <category term="基础算法" scheme="https://www.anjinyang.top/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
      <category term="深度优先搜索" scheme="https://www.anjinyang.top/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
      <category term="广度优先搜索" scheme="https://www.anjinyang.top/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>最短路径专题</title>
    <link href="https://www.anjinyang.top/2019/06/02/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84floyd%E3%80%81dijkstra%E3%80%81dijkstra+%20heap%E3%80%81bellman-flod%E3%80%81spfa/"/>
    <id>https://www.anjinyang.top/2019/06/02/最短路径floyd、dijkstra、dijkstra+ heap、bellman-flod、spfa/</id>
    <published>2019-06-02T01:43:01.000Z</published>
    <updated>2019-10-16T03:05:38.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="畅通工程续"><a href="#畅通工程续" class="headerlink" title="畅通工程续"></a>畅通工程续</h1><p>Problem Description</p><p>某省自从实行了很多年的畅通工程计划后，终于修建了很多路。不过路多了也不好，每次要从一个城镇到另一个城镇时，都有许多种道路方案可以选择，而某些方案要比另一些方案行走的距离要短很多。这让行人很困扰。</p><p>现在，已知起点和终点，请你计算出要从起点到终点，最短需要行走多少距离。 <a id="more"></a> </p><p>Input</p><p>本题目包含多组数据，请处理到文件结束。<br>每组数据第一行包含两个正整数N和M(0&lt;N&lt;200,0&lt;M&lt;1000)，分别代表现有城镇的数目和已修建的道路的数目。城镇分别以0～N-1编号。<br>接下来是M行道路信息。每一行有三个整数A,B,X(0&lt;=A,B&lt;N,A!=B,0&lt;X&lt;10000),表示城镇A和城镇B之间有一条长度为X的双向道路。<br>再接下一行有两个整数S,T(0&lt;=S,T&lt;N)，分别代表起点和终点。</p><p>Output</p><p>对于每组数据，请在一行里输出最短需要行走的距离。如果不存在从S到T的路线，就输出-1.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">0 1 1</span><br><span class="line">0 2 3</span><br><span class="line">1 2 1</span><br><span class="line">0 2</span><br><span class="line">3 1</span><br><span class="line">0 1 1</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><h3 id="floyd-暴力算法，核心代码三个for"><a href="#floyd-暴力算法，核心代码三个for" class="headerlink" title="floyd 暴力算法，核心代码三个for"></a>floyd 暴力算法，核心代码三个for</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">205</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m,st,ed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">            arr[i][j]=(i==j?<span class="number">0</span>:inf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span><span class="comment">//时间复杂度o（n^3） 数据量小于1000时可用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;++k)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">                arr[i][j]=min(arr[i][j],arr[i][k]+arr[k][j]);<span class="comment">//直接从i到j还是i到中转点k后到j近取最小更新最短</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        init();<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">            <span class="keyword">if</span>(arr[a][b]&gt;c)arr[a][b]=arr[b][a]=c;<span class="comment">//因为是双向，所以尽量取最小</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        floyd();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;st&gt;&gt;ed;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;(arr[st][ed]==inf?<span class="number">-1</span>:arr[st][ed])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dijsktra算法"><a href="#dijsktra算法" class="headerlink" title="dijsktra算法"></a>dijsktra算法</h3><p>用于无负边权的 单元 最短路径问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">205</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[N][N];</span><br><span class="line"><span class="keyword">int</span> dis[N];<span class="comment">//存储某个点到各个点的最短路径</span></span><br><span class="line"><span class="keyword">bool</span> vis[N];<span class="comment">//不能成环，所以判断某个点是否走过</span></span><br><span class="line"><span class="keyword">int</span> n,m,st,ed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">            arr[i][j]=(i==j?<span class="number">0</span>:inf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span><span class="comment">//每次循环找最短边，然后更新某个点通过最短边到每个点的最短路径，每更新一次标记用过的边防止形成环</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;++i)<span class="comment">//某个点到其他点的最短路肯定不是环，所以n个点最多有n-1条边，要找的最短路径可能走前面的最短路径，所以最多循环n-1次一定可以找到</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> minv=inf;<span class="comment">//循环每次为了找到某个点到其他点的最短边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">            <span class="keyword">if</span>(dis[j]&lt;minv&amp;&amp;!vis[j])minv=dis[j],k=j;<span class="comment">//第一次这里忘了加vis错误，因为不能走走过的点</span></span><br><span class="line">        vis[k]=<span class="literal">true</span>;<span class="comment">//遍历过后找到了一个最短的边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;++v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[k][v]&lt;inf)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v]=min(dis[v],dis[k]+arr[k][v]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">            <span class="keyword">if</span>(arr[a][b]&gt;c)arr[a][b]=arr[b][a]=c;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;st&gt;&gt;ed;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)dis[i]=arr[st][i];<span class="comment">//初始化起点</span></span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);<span class="comment">//初始化用过的点</span></span><br><span class="line">        vis[st]=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        dijkstra();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;(dis[ed]==inf?<span class="number">-1</span>:dis[ed])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dijkstra-heap算法"><a href="#dijkstra-heap算法" class="headerlink" title="dijkstra+ heap算法"></a>dijkstra+ heap算法</h3><p>时间复杂度o((m+n)logn)级别小于n^2。利用优先队列自动排序，寻找最短边。这里有两种写法，一种用二维数组存储，另一种用邻接表存储。邻接表适用于边特别多的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">205</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[N][N];</span><br><span class="line"><span class="keyword">int</span> dis[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> n,m,st,ed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,inf,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">            arr[i][j]=(i==j?<span class="number">0</span>:inf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dis[st]=<span class="number">0</span>;<span class="comment">//忘记了，wa，从st开始，dis[st]=0，否则在例如第一次循环的过程中，到其他点距离为0x3f3f3f3f+某个值不越界，但是很大，第一次相当于答案加了0x3f3f3f3f</span></span><br><span class="line">    priority_queue&lt;PII,<span class="built_in">vector</span>&lt;PII&gt;,greater&lt;PII&gt; &gt; q;</span><br><span class="line">    q.push(&#123;<span class="number">0</span>,st&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        PII now=q.top();q.pop();<span class="comment">//greater小顶堆自动排序队首为最小，less队首最大大顶堆。用这个来找最短边。</span></span><br><span class="line">        <span class="keyword">int</span> vi=now.second;<span class="comment">//最短边的另一端端点</span></span><br><span class="line">        <span class="keyword">if</span>(vis[vi])<span class="keyword">continue</span>;</span><br><span class="line">        vis[vi]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i]&amp;&amp;dis[i]&gt;dis[vi]+arr[vi][i])<span class="comment">//比较通过最短边是否为最短路径，更新到每个点的最短路径</span></span><br><span class="line">            &#123;</span><br><span class="line">                dis[i]=dis[vi]+arr[vi][i];</span><br><span class="line">                q.push(&#123;dis[i],i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        init();<span class="comment">//初始化应该在输入之前，否则数据没输入。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)<span class="comment">//这里不要错，m个店</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">            arr[a][b]=arr[b][a]=min(arr[a][b],c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;st&gt;&gt;ed;</span><br><span class="line"></span><br><span class="line">        dijkstra();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;(dis[ed]==inf?<span class="number">-1</span>:dis[ed])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表写法。存在大量边的情况下适合用邻接表</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUSH(x,y,z) G[x].push_back(&#123;y,z&#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">205</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,st,ed;</span><br><span class="line"><span class="built_in">vector</span>&lt;P&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,inf,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)G[i].clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dis[st]=<span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;P,<span class="built_in">vector</span>&lt;P&gt;,greater&lt;P&gt; &gt; q;</span><br><span class="line">    q.push(&#123;<span class="number">0</span>,st&#125;);</span><br><span class="line">    <span class="keyword">while</span>(q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        P now=q.top();</span><br><span class="line">        q.pop();<span class="comment">//选最短边，找到最短边的另一个端点</span></span><br><span class="line">        <span class="keyword">int</span> u=now.second;</span><br><span class="line">        <span class="keyword">if</span>(vis[u])<span class="keyword">continue</span>;</span><br><span class="line">        vis[u]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v=G[u][i].first;</span><br><span class="line">            <span class="keyword">int</span> cost=G[u][i].second;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v]&amp;&amp;dis[v]&gt;dis[u]+cost)<span class="comment">//遍历更新，通过最短边到点G[u][i].first的最短距离。检测vis[v]是否走过，因为要更新通过u到各个点，防止成环。</span></span><br><span class="line">            &#123;</span><br><span class="line">                dis[v]=dis[u]+cost;</span><br><span class="line">                q.push(&#123;dis[v],v&#125;);<span class="comment">//仅c++11以上版本编译器支持。建议写成make_pair(int,int)，make_pair作用是把参数变成pair类型，兼容所有版本，写法：q.push(make_pair&lt;int,int&gt;);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">            PUSH(a,b,c);<span class="comment">//不用判断G[a][b].second&gt;c因为，首先第一次输入用不上，其次如果出现重复数据，在更新的时候不影响更新他的最小值。</span></span><br><span class="line">            PUSH(b,a,c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;st&gt;&gt;ed;</span><br><span class="line"></span><br><span class="line">        dijkstra();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*for(int i=0;i&lt;m;++i)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            for(int j=0;j&lt;G[i].size();++j)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                cout&lt;&lt;G[i][j].first&lt;&lt;" "&lt;&lt;G[i][j].second&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;(dis[ed]==inf?<span class="number">-1</span>:dis[ed])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bellman-flod算法"><a href="#bellman-flod算法" class="headerlink" title="bellman-flod算法"></a>bellman-flod算法</h3><p>dijkstra无法解决负权问题，此算法可以，核心代码4行，循环n - 1次。</p><p>如果存在负边权，则无最短路径。</p><p>如何保证不成环，因为总共对每条边最多做n - 1次松弛，每次松弛只有两种可能情况（1）利用未用过的较短的边松弛（2）利用负边松弛，且只要用负边权，下次还会用用过的负边权。所以松弛n - 1次，最多利用n - 1条边，总共n个点所以不会成环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,st,ed;</span><br><span class="line"><span class="keyword">int</span> pro[N],dis[N],u[N],v[N],w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bellman_Ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> k = <span class="number">0</span>;k &lt; n - <span class="number">1</span>; ++ k )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++ i )pro[i] = dis[i];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m; ++ i )</span><br><span class="line">        &#123;</span><br><span class="line">            dis[v[i]] = min(dis[v[i]],dis[u[i]] + w[i]);</span><br><span class="line">            dis[u[i]] = min(dis[u[i]],dis[v[i]] + w[i]);<span class="comment">//无向图需要反向更新一次</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> check = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++ i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pro[i] != dis[i])</span><br><span class="line">            &#123;</span><br><span class="line">                check = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(check)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> check = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m; ++ i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[v[i]] &gt; dis[u[i]] + w[i])</span><br><span class="line">        &#123;</span><br><span class="line">            check = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(check)<span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m; ++ i )<span class="built_in">cin</span> &gt;&gt; u[i] &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">        <span class="built_in">memset</span>(dis,INF,<span class="keyword">sizeof</span> dis);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; st &gt;&gt; ed;</span><br><span class="line"></span><br><span class="line">        dis[st] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Bellman_Ford();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ( dis[ed] == INF ? <span class="number">-1</span> : dis[ed]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bellman-flod-算法-队列优化-（spfa算法）"><a href="#Bellman-flod-算法-队列优化-（spfa算法）" class="headerlink" title="Bellman-flod 算法 + 队列优化 （spfa算法）"></a>Bellman-flod 算法 + 队列优化 （spfa算法）</h3><p>在Bellman-flod 算法中可以发现，很多松弛是无法进行的，只有当某一条边松弛之后，他的邻边才有可能松弛。</p><p>每次成功松弛的点入队，每次循环用已经松弛过的边松弛其他的边。</p><p>判断有无负环：如果某个点进入队列的次数超过一定次数则存在负环（在一次循环中可能会更新多次，但只入队一次，更新次数不能决定是否成环，因为一条边可以同时由许多其他边更新，一旦其他边更新，对于当前要检测是否成环的边的更新次数会超过 n - 1，入队或者出队次数才能代表该边的松弛情况，当它入队超过n - 1时，表明成环）。也可以利用Bellman-flod中检测负边权的方法。</p><p>期望的时间复杂度O(kE)， 其中k为所有顶点进队的平均次数，可以证明k一般小于等于2。</p><p>SPFA 在形式上和宽度优先搜索(bfs)非常类似，不同的是宽度优先搜索中一个点出了队列就不可能重新进入队列，但是SPFA中一个点可能在出队列之后再次被放入队列，也就是一个点改进过其它的点之后，过了一段时间可能本身被改进，于是再次用来改进其它的点，这样反复迭代下去。</p><p>SPFA算法有两个优化算法 SLF 和 LLL。</p><ul><li><p>SLF：Small Label First 策略，设要加入的节点是j，队首元素为i，若dist(j)&lt;dist(i)，则将j插入队首，否则插入队尾。</p></li><li><p>LLL：Large Label Last 策略，设队首元素为i，队列中所有dist值的平均值为x，若dist(i)&gt;x则将i插入到队尾，查找下一元素，直到找到某一i使得dist(i)&lt;=x，则将i出对进行松弛操作。</p></li><li><p>引用网上资料，SLF 可使速度提高 15 ~ 20%；SLF + LLL 可提高约 50%。 在实际的应用中SPFA的算法时间效率不是很稳定，为了避免最坏情况的出现，通常使用效率更加稳定的Dijkstra算法。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUSH(x,y,z) G[x].push(make_pair(y,z))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">int</span> n,m,st,ed;</span><br><span class="line"><span class="keyword">int</span> dis[N],arr[N][N],check[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="built_in">memset</span>(dis,INF,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="built_in">memset</span>(check,<span class="number">0</span>,<span class="keyword">sizeof</span> check);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++ i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; n; ++ j )</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i][j] = arr[j][i] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    vis[st] = <span class="literal">true</span>;</span><br><span class="line">    dis[st] = <span class="number">0</span>;</span><br><span class="line">    q.push(st);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[now] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++ i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[i] &gt; dis[now] + arr[now][i])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[i] = dis[now] + arr[now][i];</span><br><span class="line">                <span class="keyword">if</span>(!vis[i])<span class="comment">//把松弛过但不在队列中的边推进去，进而松弛其他边</span></span><br><span class="line">                &#123;</span><br><span class="line">                    check[i] ++;</span><br><span class="line">                    <span class="keyword">if</span>(check[i] &gt; n - <span class="number">1</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">                        dis[ed] = INF;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    vis[i] = <span class="literal">true</span>;</span><br><span class="line">                    q.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m; ++ i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            arr[a][b] = arr[b][a] = min(arr[a][b],c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; st &gt;&gt; ed;</span><br><span class="line">        spfa();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (dis[ed] == INF ? <span class="number">-1</span> : dis[ed]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接表写法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUSH(x,y,z) G[x].push_back(make_pair(y,z))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,st,ed,dis[N],check[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;P&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,INF,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="built_in">memset</span>(check,<span class="number">0</span>,<span class="keyword">sizeof</span> check);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N; ++ i )G[i].clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(st);</span><br><span class="line">    dis[st] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[now] = <span class="literal">false</span>;<span class="comment">//这里不能丢，如果vis[now]更新了，需要再次放入队列。</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G[now].size(); ++ i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[now][i].first;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &gt; dis[now] + G[now][i].second)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[now] + G[now][i].second;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m; ++ i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            PUSH(a,b,c);</span><br><span class="line">            PUSH(b,a,c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; st &gt;&gt; ed;</span><br><span class="line">        spfa();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (dis[ed] == INF ? <span class="number">-1</span> : dis[ed]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前向星和链式前向星"><a href="#前向星和链式前向星" class="headerlink" title="前向星和链式前向星"></a>前向星和链式前向星</h3><h5 id="前向星"><a href="#前向星" class="headerlink" title="前向星"></a>前向星</h5><p>是一种特殊的边集数组,我们把边集数组中的每一条边按照起点从小到大排序,如果起点相同就按照终点从小到大排序,</p><p>并记录下以某个点为起点的所有边在数组中的起始位置和存储长度,那么前向星就构造好了.</p><p>用len[i]来记录所有以i为起点的边在数组中的存储长度.</p><p>用head[i]记录以i为边集在数组中的第一个存储位置.</p><p><u>最终可以达到快速访问指定起点的边集。</u>缺点需要排序，快排nlogn.</p><h5 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h5><p>事实上根本不需要排序，我们的目的是在一堆数组中直接访问指定起点的边集，我们可以牺牲一些空间保存同一类集合的下标即可，对于每一条边需要保存其起点、终点、长度等。（如果是开太多数组，牺牲太多，又和邻接矩阵没差，小声bb）</p><p>对比：链式前向星和领接表的遍历速度都不如邻接矩阵，但存储的边的数量都比邻接矩阵要多，极端情况下邻接表可能会卡vector。</p><p>存边</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> head[N];<span class="comment">//一般初始化为-1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to,w;</span><br><span class="line">&#125;edge[N];</span><br></pre></td></tr></table></figure><p>写入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].next = head[u];<span class="comment">//指向上一条同起点的边</span></span><br><span class="line">    head[u] = cnt ++;<span class="comment">//更新head[u]为当前边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>edge[i].to</code>表示第i条边的终点,<code>edge[i].next</code>表示与第i条边同起点的下一条边的存储位置,<code>edge[i].w</code>为边权值.</p><p>另外还有一个数组<code>head[]</code>,它是用来表示以i为起点的第一条边存储的位置,实际上你会发现这里的第一条边存储的位置其实</p><p>在以i为起点的所有边的最后输入的那个编号.</p><p>整数快读模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">'-'</span>)f = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">        res = res * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> f * res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链式前向星 模板题 洛谷P4479</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to,w;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,st,ed,cnt;</span><br><span class="line"><span class="keyword">int</span> head[N],dis[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="built_in">memset</span>(dis,INF,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">'-'</span>)f = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res = res * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch =getchar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f * res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;P,<span class="built_in">vector</span>&lt;P&gt;,greater&lt;P&gt; &gt; q;</span><br><span class="line">    dis[st] = <span class="number">0</span>;</span><br><span class="line">    q.push(make_pair(<span class="number">0</span>,st));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        P now = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> u = now.second;</span><br><span class="line">        <span class="keyword">if</span>(vis[u])<span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = head[u]; ~ i;i = edge[i].next)</span><br><span class="line">        &#123;<span class="comment">//因为head初始化为-1，当i = -1 时结束，因为-1存储形式为111……111 按位去反后为0，所以可以写作 ~ i</span></span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v] &amp;&amp; dis[v] &gt; dis[u] + edge[i].w)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + edge[i].w;</span><br><span class="line">                q.push(make_pair(dis[v],v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    n = rd();</span><br><span class="line">    m = rd();</span><br><span class="line">    st = rd();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m; ++ i )&#123;</span><br><span class="line">        a = rd();</span><br><span class="line">        b = rd();</span><br><span class="line">        c = rd();</span><br><span class="line">        add(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dijkstra();</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++ i )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,dis[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;畅通工程续&quot;&gt;&lt;a href=&quot;#畅通工程续&quot; class=&quot;headerlink&quot; title=&quot;畅通工程续&quot;&gt;&lt;/a&gt;畅通工程续&lt;/h1&gt;&lt;p&gt;Problem Description&lt;/p&gt;
&lt;p&gt;某省自从实行了很多年的畅通工程计划后，终于修建了很多路。不过路多了也不好，每次要从一个城镇到另一个城镇时，都有许多种道路方案可以选择，而某些方案要比另一些方案行走的距离要短很多。这让行人很困扰。&lt;/p&gt;
&lt;p&gt;现在，已知起点和终点，请你计算出要从起点到终点，最短需要行走多少距离。&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://www.anjinyang.top/tags/algorithm/"/>
    
      <category term="最短路" scheme="https://www.anjinyang.top/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="图论" scheme="https://www.anjinyang.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>日常赛-糖果传递题解</title>
    <link href="https://www.anjinyang.top/2019/06/02/%E7%B3%96%E6%9E%9C%E4%BC%A0%E9%80%92/"/>
    <id>https://www.anjinyang.top/2019/06/02/糖果传递/</id>
    <published>2019-06-02T01:43:01.000Z</published>
    <updated>2019-10-16T03:05:14.234Z</updated>
    
    <content type="html"><![CDATA[<h1 id="糖果传递题解"><a href="#糖果传递题解" class="headerlink" title="糖果传递题解"></a>糖果传递题解</h1><p>有n个小朋友坐成一圈，每人有a[i]个糖果。</p><p>每人只能给左右两人传递糖果。</p><p>每人每次传递一个糖果代价为1。</p><p>求使所有人获得均等糖果的最小代价。 <a id="more"></a> </p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入一个正整数n，表示小朋友的个数。</p><p>接下来n行，每行一个整数a[i]，表示第i个小朋友初始得到的糖果的颗数。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最小代价。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤1000000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>分析：</p><p>多个考点综合的问题，感觉像一道数学题。</p><p>对于每个人，假设他的糖果数要经过两类变化：1、从后一个人拿。2、给前一个人</p><p>最终的变化结果是变为ave。</p><p>所以有</p><ul><li>a[1]-X1+X2=ave    X2=X1-(a[1]-ave)</li><li>a[2]-X2+X3=ave        X3=X1-(a[2]+a[1]-2*ave) </li></ul><p>设c[1]=a[1]-ave</p><p>c[2]=c[1]+a[2]-ave</p><p>则有c[i]=c[i-1]+a[i]-ave</p><p>则有问题|X1|+|X2|+……+|Xn|的和最小每个都可以用X1表示为</p><p>|X1|+|X1-c[1]|+|X2-c[2]|+……+|X1-c[n-1]|   </p><p>绝对值的含义又可以表示数轴上Xi到Ci的距离</p><p>所以问题转化为在c[1]到c[n-1]中选一个点到所有点的距离的和最短</p><p>（即中位数）</p><p>注意：不应该加上abs(c[n]-c[mid])，并且ans最后应该加上mid</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N],c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">LL sum=<span class="number">0</span>;<span class="comment">//记得初始化为0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">sum+=a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ave=sum/n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">c[i]=c[i<span class="number">-1</span>]+a[i]-ave;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(c+<span class="number">1</span>,c+n);<span class="comment">//c[0]=0不能参与排序影响结果</span></span><br><span class="line"></span><br><span class="line">LL ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> pos=n&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans+=<span class="built_in">abs</span>(c[pos]-c[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ans+=<span class="built_in">abs</span>(c[pos]);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;糖果传递题解&quot;&gt;&lt;a href=&quot;#糖果传递题解&quot; class=&quot;headerlink&quot; title=&quot;糖果传递题解&quot;&gt;&lt;/a&gt;糖果传递题解&lt;/h1&gt;&lt;p&gt;有n个小朋友坐成一圈，每人有a[i]个糖果。&lt;/p&gt;
&lt;p&gt;每人只能给左右两人传递糖果。&lt;/p&gt;
&lt;p&gt;每人每次传递一个糖果代价为1。&lt;/p&gt;
&lt;p&gt;求使所有人获得均等糖果的最小代价。&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://www.anjinyang.top/tags/algorithm/"/>
    
      <category term="递推" scheme="https://www.anjinyang.top/tags/%E9%80%92%E6%8E%A8/"/>
    
  </entry>
  
  <entry>
    <title>背包专题</title>
    <link href="https://www.anjinyang.top/2019/06/02/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>https://www.anjinyang.top/2019/06/02/背包问题/</id>
    <published>2019-06-02T01:43:01.000Z</published>
    <updated>2019-10-16T03:04:16.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><ol><li>01背包（一个物品只能选一次，换言之一个物品只有选和不选两种状态）</li><li>完全背包（每个物品不限次数）</li><li>多重背包（每个物品选的次数不一样）</li><li>混合背包（物品多种，问最大价值）</li><li>二维费用的背包 </li><li>分组背包（物品分组，每组内物品互斥）</li><li>背包问题求方案数</li><li>背包问题方案 <a id="more"></a> </li><li>有依赖的背包问题（有限制，不随便选）</li></ol><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><p>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。</p><p>第 i 件物品的体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><p>输入格式</p><p>第一行两个整数N，V，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 N 行，每行两个整数vi,wi，用空格隔开，分别表示第 i件物品的体积和价值。</p><p>输出格式</p><p>输出一个整数，表示最大价值。</p><p>数据范围</p><p>0&lt;N,V≤1000<br>0&lt;vi,wi≤1000</p><p> 输入样例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><p> 输出样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><h4 id="朴素解法，二维动态规划"><a href="#朴素解法，二维动态规划" class="headerlink" title="朴素解法，二维动态规划"></a>朴素解法，二维动态规划</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">f[i][j] 表示只有前i个物品，总体积是j，总最大价值</span><br><span class="line"></span><br><span class="line">答案为 res = max(f[n][0 - v])</span><br><span class="line"></span><br><span class="line">f[i][j]:</span><br><span class="line">1.不选第i个物品 f[i][j] = f[i - 1][j]</span><br><span class="line">2.选第i个物品 f[i][j] = f[i - 1][j - v[i]] + w[i]</span><br><span class="line"></span><br><span class="line">f[i][j] = max(1,2)</span><br><span class="line"></span><br><span class="line">f[0][0] = 0</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"><span class="keyword">int</span> v[N],w[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++ i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++ i )</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= m; ++ j )</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= v[i])</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j] = max(f[i][j],f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= m; ++ i )res = max(res,f[n][i])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：按照这个方程递推完毕后，最终的答案并不一定是f（N）（V），而是f（N）（0..V）的最大值。如果将状态的定义中的“恰”字去掉，在转移方程中就要再加入一项f（i）（v-1），这样就可以保证f（N）（V）就是最后的答案</p><h6 id="一维优化解法-优化了空间"><a href="#一维优化解法-优化了空间" class="headerlink" title="一维优化解法(优化了空间)"></a>一维优化解法(优化了空间)</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="keyword">int</span> v[N],w[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++ i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++ i )</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = m;j &gt;= v[i]; j -- )</span><br><span class="line">            f[j] = max(f[j],f[j - v[i]] + w[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。</p><p>第 i 种物品的体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><p>输入格式</p><p>第一行两个整数N，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i种物品的体积和价值。</p><p>输出格式</p><p>输出一个整数，表示最大价值。</p><p>数据范围</p><p>0&lt;N,V≤1000<br>0&lt;vi,wi≤1000</p><p>输入样例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><p>输出样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,f[N];<span class="comment">//如果是恰好用v，则只需要初始化为负无穷</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++ i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v,w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = v;j &lt;= m; ++ j )</span><br><span class="line">            f[j] = max(f[j],f[j - v] + w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>有 N 种物品和一个容量是 V 的背包。</p><p>第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p><p> 输入格式</p><p>第一行两个整数N，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。</p><p> 输出格式</p><p>输出一个整数，表示最大价值。</p><p> 数据范围</p><p>0&lt;N,V≤100<br>0&lt;vi,wi,si≤100</p><p> 输入样例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2 3</span><br><span class="line">2 4 1</span><br><span class="line">3 4 3</span><br><span class="line">4 5 2</span><br></pre></td></tr></table></figure><p> 输出样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><ol><li>f[1] = 0 答案为f[m]</li><li>f[0] = 0,其他权威负无穷，答案为max(f[0 … v])</li></ol><p>朴素解法，时间复杂度 o（n^3）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e2</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++ i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v,w,s;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = m;j &gt;= <span class="number">0</span>;j -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= s &amp;&amp; k * v &lt;= j; ++ k )</span><br><span class="line">                f[j] = max(f[j],f[j - k * v] + k * w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背包问题&quot;&gt;&lt;a href=&quot;#背包问题&quot; class=&quot;headerlink&quot; title=&quot;背包问题&quot;&gt;&lt;/a&gt;背包问题&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;01背包（一个物品只能选一次，换言之一个物品只有选和不选两种状态）&lt;/li&gt;
&lt;li&gt;完全背包（每个物品不限次数）&lt;/li&gt;
&lt;li&gt;多重背包（每个物品选的次数不一样）&lt;/li&gt;
&lt;li&gt;混合背包（物品多种，问最大价值）&lt;/li&gt;
&lt;li&gt;二维费用的背包 &lt;/li&gt;
&lt;li&gt;分组背包（物品分组，每组内物品互斥）&lt;/li&gt;
&lt;li&gt;背包问题求方案数&lt;/li&gt;
&lt;li&gt;背包问题方案&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://www.anjinyang.top/tags/algorithm/"/>
    
      <category term="基础算法" scheme="https://www.anjinyang.top/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
      <category term="dp" scheme="https://www.anjinyang.top/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>洛谷-宇宙大总统</title>
    <link href="https://www.anjinyang.top/2019/06/02/%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8Epair%E6%B4%9B%E8%B0%B7%20%E5%AE%87%E5%AE%99%E5%A4%A7%E6%80%BB%E7%BB%9F/"/>
    <id>https://www.anjinyang.top/2019/06/02/结构体与pair洛谷 宇宙大总统/</id>
    <published>2019-06-02T01:43:01.000Z</published>
    <updated>2019-10-16T03:04:37.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="洛谷-宇宙大总统"><a href="#洛谷-宇宙大总统" class="headerlink" title="洛谷 宇宙大总统"></a>洛谷 宇宙大总统</h1><p>分析：其实就是一道字符串排序，主要学习的写法一结构体，二pair。另外需要牢记比较函数，大于号为降序，小于号为升序。这道题用来熟练stl库。 <a id="more"></a> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt; P;</span><br><span class="line">P arr[<span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(P a, P b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.second.size()==b.second.size())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a.second&gt;b.second;<span class="comment">//降序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a.second.size()&gt;b.second.size();<span class="comment">//降序</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i].first=i+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;arr[i].second;</span><br><span class="line">&#125;</span><br><span class="line">sort(arr,arr+n,cmp);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;arr[<span class="number">0</span>].first&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;arr[<span class="number">0</span>].second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;洛谷-宇宙大总统&quot;&gt;&lt;a href=&quot;#洛谷-宇宙大总统&quot; class=&quot;headerlink&quot; title=&quot;洛谷 宇宙大总统&quot;&gt;&lt;/a&gt;洛谷 宇宙大总统&lt;/h1&gt;&lt;p&gt;分析：其实就是一道字符串排序，主要学习的写法一结构体，二pair。另外需要牢记比较函数，大于号为降序，小于号为升序。这道题用来熟练stl库。&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://www.anjinyang.top/tags/algorithm/"/>
    
      <category term="基础算法" scheme="https://www.anjinyang.top/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
      <category term="结构体" scheme="https://www.anjinyang.top/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    
      <category term="pair" scheme="https://www.anjinyang.top/tags/pair/"/>
    
      <category term="排序" scheme="https://www.anjinyang.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>排序专题</title>
    <link href="https://www.anjinyang.top/2019/06/02/%E6%8E%92%E5%BA%8F%E5%9F%BA%E7%A1%80/"/>
    <id>https://www.anjinyang.top/2019/06/02/排序基础/</id>
    <published>2019-06-02T01:43:01.000Z</published>
    <updated>2019-10-16T03:04:53.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序基础"><a href="#排序基础" class="headerlink" title="排序基础"></a>排序基础</h2><ol><li><p>排序目的使数据更容易处理。</p></li><li><p>排序要先找到排序键。（以什么依据排序）</p></li><li><p>数据存储用到数组、结构体或类。</p></li><li><p>排序需要考虑算法复杂度和稳定性。</p><ul><li>稳定性指数据存在两个或两个以上相等元素时，这些元素相对位置在排序前后不变。</li></ul></li></ol><p>其他考虑 <a id="more"></a> </p><ol><li>除保存数据以外是否还需要额外内存</li><li>输入数据的特征是否会对复杂度产生影响</li></ol><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>可以理解为打牌的时候，插入排序的动作。抽出一张牌，插入到已经排好序的适当位置。反复操作直到有序。</p><p>稳定排序。如果排序v&gt;arr[j]加了等于号可分析得出失去稳定性。</p><p>Q1:一个无序的数列，插入排序时第一个抽出来的数插入到哪里？</p><p>reply:输入n个数，下标从0到n-1。排序时从1到n-1，把第一个数（单独的第一个数）可以看做有序。（在归并排序中有类似想法）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> array1[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertsort</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> arr[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v=arr[i];</span><br><span class="line">        j=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;arr[j]&gt;v)<span class="comment">//升序</span></span><br><span class="line">        &#123;</span><br><span class="line">            arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        arr[j+<span class="number">1</span>]=v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;array1[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    insertsort(n,array1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">cout</span>&lt;&lt;array1[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>经典中的经典。顾名思义，冒泡排序就是让数组元素，像水中的气泡一样逐渐上浮。</p><p>这里补充一个c++交换数值的函数swap(arr[j],arr[j+1])</p><p>稳定排序。如果排序arr[j]&gt;arr[j+1]加了等于号可分析得出失去稳定性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> array1[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubblesort</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> arr[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>&amp;&amp;flag;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n-i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])<span class="comment">//升序</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp=arr[i];</span><br><span class="line">                arr[i]=arr[j];</span><br><span class="line">                arr[j]=temp;</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void bubblesort(int n,int arr[])</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int flag=1;</span></span><br><span class="line"><span class="comment">    while(flag)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        flag=0;</span></span><br><span class="line"><span class="comment">        for(int j=n-1;j&gt;0;j--)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            if(arr[j]&lt;arr[j-1])//升序排列</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                int temp=arr[j];</span></span><br><span class="line"><span class="comment">                arr[j]=arr[j-1];</span></span><br><span class="line"><span class="comment">                arr[j-1]=temp;</span></span><br><span class="line"><span class="comment">                flag=1;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;array1[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bubblesort(n,array1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">cout</span>&lt;&lt;array1[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;排序基础&quot;&gt;&lt;a href=&quot;#排序基础&quot; class=&quot;headerlink&quot; title=&quot;排序基础&quot;&gt;&lt;/a&gt;排序基础&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;排序目的使数据更容易处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;排序要先找到排序键。（以什么依据排序）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据存储用到数组、结构体或类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;排序需要考虑算法复杂度和稳定性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;稳定性指数据存在两个或两个以上相等元素时，这些元素相对位置在排序前后不变。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其他考虑&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://www.anjinyang.top/tags/algorithm/"/>
    
      <category term="基础算法" scheme="https://www.anjinyang.top/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="https://www.anjinyang.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>递归与递推专题</title>
    <link href="https://www.anjinyang.top/2019/06/02/%E9%80%92%E5%BD%92%E4%B8%93%E9%A1%B9/"/>
    <id>https://www.anjinyang.top/2019/06/02/递归专项/</id>
    <published>2019-06-02T01:43:01.000Z</published>
    <updated>2019-10-16T03:04:32.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="递归实现指数型枚举"><a href="#递归实现指数型枚举" class="headerlink" title="递归实现指数型枚举"></a>递归实现指数型枚举</h2><p>从 1~n 这 n 个整数中随机选取任意多个，输出所有可能的选择方案。 <a id="more"></a> </p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入一个整数n。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>每行输出一种方案。</p><p>同一行内的数必须升序排列，相邻两个数用恰好1个空格隔开。</p><p>对于没有选任何数的方案，输出空行。</p><p>本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">if</span>(state&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(u+<span class="number">1</span>,state);</span><br><span class="line">    dfs(u+<span class="number">1</span>,state|<span class="number">1</span>&lt;&lt;u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归实现组合型枚举"><a href="#递归实现组合型枚举" class="headerlink" title="递归实现组合型枚举"></a>递归实现组合型枚举</h2><p>从 1~n 这 n 个整数中随机选出 m 个，输出所有可能的选择方案。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>两个整数n,m 在同一行用空格隔开。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>按照从小到大的顺序输出所有方案，每行1个。</p><p>首先，同一行内的数升序排列，相邻两个数用一个空格隔开。</p><p>其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如1 3 5 7排在1 3 6 8前面）。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> sum,<span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum+n-u&lt;m)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sum==m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">if</span>(state&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if(u==n)return; 第一个if会直接判断出去所以不需要写这句话</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    dfs(u+<span class="number">1</span>,sum+<span class="number">1</span>,state|<span class="number">1</span>&lt;&lt;u);</span><br><span class="line">    dfs(u+<span class="number">1</span>,sum,state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归实现排列型枚举"><a href="#递归实现排列型枚举" class="headerlink" title="递归实现排列型枚举"></a>递归实现排列型枚举</h2><p>把 1~n 这 n 个整数排成一行后随机打乱顺序，输出所有可能的次序。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>一个整数n。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>按照从小到大的顺序输出所有方案，每行1个。</p><p>首先，同一行相邻两个数用一个空格隔开。</p><p>其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//n个坑，枚举哪个数放到第一个坑，然后枚举下一个坑，枚举没有放过的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;path;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:path)<span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(state&gt;&gt;i&amp;<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            path.push_back(i+<span class="number">1</span>);</span><br><span class="line">            dfs(u+<span class="number">1</span>,state|<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            path.pop_back();<span class="comment">//枚举完当前情况后，恢复现场。保证同一次枚举的时候，对于所有的分支在进入之前他的所有状态都是一样的。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="费解的开关"><a href="#费解的开关" class="headerlink" title="费解的开关"></a>费解的开关</h2><p>你玩过“拉灯”游戏吗？25盏灯排成一个5x5的方形。每一个灯都有一个开关，游戏者可以改变它的状态。每一步，游戏者可以改变某一个灯的状态。游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。</p><p>我们用数字“1”表示一盏开着的灯，用数字“0”表示关着的灯。下面这种状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10111</span><br><span class="line">01101</span><br><span class="line">10111</span><br><span class="line">10000</span><br><span class="line">11011</span><br></pre></td></tr></table></figure><p>在改变了最左上角的灯的状态后将变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">01111</span><br><span class="line">11101</span><br><span class="line">10111</span><br><span class="line">10000</span><br><span class="line">11011</span><br></pre></td></tr></table></figure><p>再改变它正中间的灯后状态将变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">01111</span><br><span class="line">11001</span><br><span class="line">11001</span><br><span class="line">10100</span><br><span class="line">11011</span><br></pre></td></tr></table></figure><p>给定一些游戏的初始状态，编写程序判断游戏者是否可能在6步以内使所有的灯都变亮。</p><h4 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入正整数n，代表数据中共有n个待解决的游戏初始状态。</p><p>以下若干行数据分为n组，每组数据有5行，每行5个字符。每组数据描述了一个游戏的初始状态。各组数据间用一个空行分隔。</p><h4 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h4><p>一共输出n行数据，每行有一个小于等于6的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。</p><p>对于某一个游戏初始状态，若6步以内无法使所有灯变亮，则输出“-1”。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;//memcpy在这儿</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> g[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;<span class="comment">//向量技巧，以此表示中心，向上，向右，向下，向左</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turn</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//按下操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)<span class="comment">//一开始写错了写了两重循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=x+dx[i],b=y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(a&gt;=<span class="number">0</span>&amp;&amp;a&lt;<span class="number">5</span>&amp;&amp;b&gt;=<span class="number">0</span>&amp;&amp;b&lt;<span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            g[a][b]^=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">1</span>&lt;&lt;<span class="number">5</span>;k++)<span class="comment">//枚举第一行的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> backup[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(backup,g,<span class="keyword">sizeof</span> g);<span class="comment">//记录原始状态</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)<span class="comment">//操作第一行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k&gt;&gt;j&amp;<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">                turn(<span class="number">0</span>,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)<span class="comment">//操作后面几行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(g[i][j]==<span class="string">'0'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    turn(i+<span class="number">1</span>,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> is_successful=<span class="literal">true</span>;<span class="comment">//根据最后一行有无0判断是否成功</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[<span class="number">4</span>][i]==<span class="string">'0'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                is_successful=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(is_successful)</span><br><span class="line">        &#123;</span><br><span class="line">            ans=min(res,ans);<span class="comment">//记录最小值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(g,backup,<span class="keyword">sizeof</span> g);<span class="comment">//返回初始状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ans&gt;<span class="number">6</span>) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//return 的位置写错了</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)<span class="built_in">cin</span>&gt;&gt;g[i];<span class="comment">//char数组不需要写到二维</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;work()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="奇怪的汉诺塔"><a href="#奇怪的汉诺塔" class="headerlink" title="奇怪的汉诺塔"></a>奇怪的汉诺塔</h2><p>汉诺塔问题，条件如下：</p><p>1、这里有A、B、C和D四座塔。</p><p>2、这里有n个圆盘，n的数量是恒定的。</p><p>3、每个圆盘的尺寸都不相同。</p><p>4、所有的圆盘在开始时都堆叠在塔A上，且圆盘尺寸从塔顶到塔底逐渐增大。</p><p>5、我们需要将所有的圆盘都从塔A转移到塔D上。</p><p>6、每次可以移动一个圆盘，当塔为空塔或者塔顶圆盘尺寸大于被移动圆盘时，可将圆盘移至这座塔上。</p><p>请你求出将所有圆盘从塔A移动到塔D，所需的最小移动次数是多少。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">15</span>],f[<span class="number">15</span>];</span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;<span class="number">13</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        d[i]=<span class="number">2</span>*d[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> f);<span class="comment">//使f中最大，后面用来min</span></span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">13</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i]=min(f[i],f[j]*<span class="number">2</span>+d[i-j]);<span class="comment">//后面的算法借鉴基本汉诺塔的算法，因为共四个柱子，最开始把一定数量的圆盘移动到一个柱子上，此时还剩两个柱子，可以完成基础汉诺塔的操作。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">12</span>;i++)<span class="built_in">cout</span>&lt;&lt;f[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="约数之和"><a href="#约数之和" class="headerlink" title="约数之和"></a>约数之和</h2><p>假设现在有两个自然数A和B，S是A^B的所有约数之和。</p><p>请你求出S mod 9901的值是多少。</p><h4 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h4><p>在一行中输入用空格隔开的两个整数A和B。</p><h4 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，代表S mod 9901的值。</p><p>分析：下图为需要用到的公式。</p><p><img src="/2019/06/02/递归专项/F:%5CANJINYANG17%5C%E5%AD%A6%E4%B9%A0%5C%E6%97%A5%E8%AE%B0%5CACM%E8%AE%AD%E7%BB%83%E6%97%A5%E8%AE%B0%5C%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98%E7%9B%B8%E5%85%B3.png" alt="数学问题相关"></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">9901</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quickpower</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a%=mod;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> k)</span><span class="comment">//这里是难点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k%<span class="number">2</span>==<span class="number">0</span>)<span class="keyword">return</span> (p%mod*sum(p,k<span class="number">-1</span>)%mod+<span class="number">1</span>)%mod;</span><br><span class="line">    <span class="keyword">return</span> (quickpower(p,k/<span class="number">2</span>+<span class="number">1</span>)+<span class="number">1</span>)%mod*sum(p,k/<span class="number">2</span>)%mod;<span class="comment">//这里不取余会有错误？错误数据50000000 50000000答案5531</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=a;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;    </span><br><span class="line">        <span class="keyword">while</span>(a%i==<span class="number">0</span>)<span class="comment">//错写成a%i!=0</span></span><br><span class="line">        &#123;</span><br><span class="line">            a/=i;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k)ans=ans*sum(i,k*b)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>)ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分形之城"><a href="#分形之城" class="headerlink" title="分形之城"></a>分形之城</h2><p>城市的规划在城市建设中是个大问题。</p><p>不幸的是，很多城市在开始建设的时候并没有很好的规划，城市规模扩大之后规划不合理的问题就开始显现。</p><p>而这座名为 Fractal 的城市设想了这样的一个规划方案，如下图所示：</p><p><img src="https://www.acwing.com/media/article/image/2019/01/07/19_1ac25efe11-city.png" alt="city.png"></p><p>当城区规模扩大之后，Fractal 的解决方案是把和原来城区结构一样的区域按照图中的方式建设在城市周围，提升城市的等级。</p><p>对于任意等级的城市，我们把正方形街区从左上角开始按照道路标号。</p><p>虽然这个方案很烂，Fractal 规划部门的人员还是想知道，如果城市发展到了等级 N，编号为 A 和 B 的两个街区的直线距离是多少。</p><p>街区的距离指的是街区的中心点之间的距离，每个街区都是边长为 10 米的正方形。</p><h4 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入正整数n，表示测试数据的数目。</p><p>以下n行，输入n组测试数据，每组一行。</p><p>每组数据包括三个整数 N,A,B, 表示城市等级以及两个街区的编号，整数之间用空格隔开。</p><h4 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h4><p>一共输出n行数据，每行对应一组测试数据的输出结果，结果四舍五入到整数。</p><p>难点在于坐标转化。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,LL&gt; PLL;</span><br><span class="line"></span><br><span class="line"><span class="function">PLL <span class="title">calc</span><span class="params">(LL n,LL m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span>&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    LL len=<span class="number">1l</span>l&lt;&lt;n<span class="number">-1</span>,cnt=<span class="number">1l</span>l&lt;&lt;<span class="number">2</span>*n<span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">auto</span> pos=calc(n<span class="number">-1</span>,m%cnt);</span><br><span class="line">    <span class="keyword">auto</span> x=pos.first,y=pos.second;</span><br><span class="line">    <span class="keyword">auto</span> z=m/cnt;</span><br><span class="line">    <span class="keyword">if</span>(z==<span class="number">0</span>) <span class="keyword">return</span> &#123;y,x&#125;;</span><br><span class="line">    <span class="keyword">if</span>(z==<span class="number">1</span>) <span class="keyword">return</span> &#123;x,y+len&#125;;</span><br><span class="line">    <span class="keyword">if</span>(z==<span class="number">2</span>) <span class="keyword">return</span> &#123;x+len,y+len&#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">2</span>*len<span class="number">-1</span>-y,len<span class="number">-1</span>-x&#125;;<span class="comment">//迷之减一，通过画图发现上面的+len确实比这里需要平移的距离长一小节</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        LL n,a,b;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">auto</span> ac=calc(n,a<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">auto</span> bc=calc(n,b<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">double</span> x=ac.first-bc.first,y=ac.second-bc.second;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.0lf\n"</span>,<span class="built_in">sqrt</span>(x*x+y*y)*<span class="number">10</span>);<span class="comment">//四舍五入保留整数.0lf，sqrt里多写了个*号导致没过</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;递归实现指数型枚举&quot;&gt;&lt;a href=&quot;#递归实现指数型枚举&quot; class=&quot;headerlink&quot; title=&quot;递归实现指数型枚举&quot;&gt;&lt;/a&gt;递归实现指数型枚举&lt;/h2&gt;&lt;p&gt;从 1~n 这 n 个整数中随机选取任意多个，输出所有可能的选择方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://www.anjinyang.top/tags/algorithm/"/>
    
      <category term="基础算法" scheme="https://www.anjinyang.top/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.anjinyang.top/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="递推" scheme="https://www.anjinyang.top/tags/%E9%80%92%E6%8E%A8/"/>
    
  </entry>
  
  <entry>
    <title>贪心专题</title>
    <link href="https://www.anjinyang.top/2019/06/02/%E8%B4%AA%E5%BF%83/"/>
    <id>https://www.anjinyang.top/2019/06/02/贪心/</id>
    <published>2019-06-02T01:43:01.000Z</published>
    <updated>2019-10-16T03:05:07.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="贪心专题"><a href="#贪心专题" class="headerlink" title="贪心专题"></a>贪心专题</h1><h3 id="防晒霜"><a href="#防晒霜" class="headerlink" title="防晒霜"></a>防晒霜</h3><p>有C头奶牛进行日光浴，第i头奶牛需要minSPF[i]到maxSPF[i]单位强度之间的阳光。 <a id="more"></a> </p><p>每头奶牛在日光浴前必须涂防晒霜，防晒霜有L种，涂上第i种之后，身体接收到的阳光强度就会稳定为SPF[i]，第i种防晒霜有cover[i]瓶。</p><p>求最多可以满足多少头奶牛进行日光浴。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入整数C和L。</p><p>接下来的C行，按次序每行输入一头牛的minSPF和maxSPF值,即第i行输入minSPF[i]和maxSPF[i]。</p><p>再接下来的L行，按次序每行输入一种防晒霜的SPF和cover值,即第i行输入SPF[i]和cover[i]。</p><p>每行的数据之间用空格隔开。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，代表最多可以满足奶牛日光浴的奶牛数目。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤C,L≤2500，<br>1≤minSPF≤maxSPF≤1000,<br>1≤SPF≤1000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">3 10</span><br><span class="line">2 5</span><br><span class="line">1 5</span><br><span class="line">6 2</span><br><span class="line">4 1</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>分析：二分图的匹配问题。匈牙利算法。当前匹配为最大匹配的条件是不存在增广路径。平衡树set或者map。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2505</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cow</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> minn,maxn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cover[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cow</span> <span class="title">cows</span>[<span class="title">N</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(cow a,cow b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.minn==b.minn)<span class="keyword">return</span> a.maxn&gt;b.maxn;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.minn&gt;b.minn;<span class="comment">//按照minspf由大到小排序是正解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c,l;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;c&gt;&gt;l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;cows[i].minn&gt;&gt;cows[i].maxn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> spf,temp;<span class="comment">// 数据中存在spf值相同的防晒霜</span></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;spf&gt;&gt;temp;</span><br><span class="line"></span><br><span class="line">        cover[spf]+=temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(cows,cows+c,cmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> temp=cows[i].maxn;temp&gt;=cows[i].minn;temp--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cover[temp]!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                cover[temp]--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2505</span>;</span><br><span class="line"><span class="keyword">int</span> c,l;<span class="comment">//接下来用什么存储牛和防晒霜的数据</span></span><br><span class="line">PII cows[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;c&gt;&gt;l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c;i++)<span class="built_in">cin</span>&gt;&gt;cows[i].first&gt;&gt;cows[i].second;</span><br><span class="line">    sort(cows,cows+c);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; spfs;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> spf,cover;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;spf&gt;&gt;cover;</span><br><span class="line">        spfs[spf]+=cover;<span class="comment">//可能同一个spf给多次</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    spfs[<span class="number">0</span>]=spfs[<span class="number">1001</span>]=c;<span class="comment">//二分查找返回大于等于某个数的第一个地址，所以要在两边加上c???</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=c<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> cow=cows[i];</span><br><span class="line">        <span class="keyword">auto</span> it=spfs.upper_bound(cow.second);<span class="comment">////lower返回大于等于,upper返回大于，再减减就可以得到小于等于某个数的最大的数</span></span><br><span class="line">        it--;</span><br><span class="line">        <span class="keyword">if</span>(it-&gt;first&gt;=cow.first &amp;&amp; it-&gt;first&lt;=cow.second)</span><br><span class="line">        &#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">if</span>(-- it-&gt;second==<span class="number">0</span>)<span class="comment">//it第一个关键字是spf第二个关键字是cover</span></span><br><span class="line">                spfs.erase(it);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="畜栏预定"><a href="#畜栏预定" class="headerlink" title="畜栏预定"></a>畜栏预定</h3><p>有N头牛在畜栏中吃草。</p><p>每个畜栏在同一时间段只能提供给一头牛吃草，所以可能会需要多个畜栏。</p><p>给定N头牛和每头牛开始吃草的时间A以及结束吃草的时间B，每头牛在[A,B]这一时间段内都会一直吃草。</p><p>当两头牛的吃草区间存在交集时（<strong>包括端点</strong>），这两头牛不能被安排在同一个畜栏吃草。</p><p>求需要的最小畜栏数目和每头牛对应的畜栏方案。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第1行：输入一个整数N。</p><p>第2-N+1行：第i+1行输入第i头牛的开始吃草时间A以及结束吃草时间B，数之间用空格隔开。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>第1行：输入一个整数，代表所需最小畜栏数。</p><p>第2..N+1行：第i+1行输入第i头牛被安排到的畜栏编号，编号从1开始，只要方案合法即可。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤50000,<br>1≤A,B≤1000000</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 10</span><br><span class="line">2 4</span><br><span class="line">3 6</span><br><span class="line">5 8</span><br><span class="line">4 7</span><br></pre></td></tr></table></figure><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e4</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">pair&lt;P,<span class="keyword">int</span>&gt; cows[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> id[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;cows[i].first.first&gt;&gt;cows[i].first.second;</span><br><span class="line">        cows[i].second=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(cows,cows+n);<span class="comment">//这里怎么排序：直接排序为什么？猜想这里排序直接对cows[i].first.first进行排序 解释：这里pair排序先根据first.first然后first.second 最后是second</span></span><br><span class="line"></span><br><span class="line">    priority_queue&lt;P,<span class="built_in">vector</span>&lt;P&gt;,greater&lt;P&gt; &gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q.empty()||q.top().first&gt;=cows[i].first.first)<span class="comment">//判断条件应该是前一个的结束时间是否大于等于当前这个的开始时间</span></span><br><span class="line">        &#123;</span><br><span class="line">            id[cows[i].second]=q.size();</span><br><span class="line">            q.push(make_pair(cows[i].first.second,q.size()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            P stall=q.top();</span><br><span class="line">            q.pop();<span class="comment">//这里忘记了pop把替换掉的删除出去</span></span><br><span class="line">            stall.first=cows[i].first.second;</span><br><span class="line">            id[cows[i].second]=stall.second;</span><br><span class="line">            q.push(stall);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;q.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)<span class="built_in">cout</span>&lt;&lt;id[i]+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="雷达设备"><a href="#雷达设备" class="headerlink" title="雷达设备"></a>雷达设备</h3><p>假设海岸是一条无限长的直线，陆地位于海岸的一侧，海洋位于另外一侧。</p><p>每个小岛都位于海洋一侧的某个点上。</p><p>雷达装置均位于海岸线上，且雷达的监测范围为d，当小岛与某雷达的距离不超过d时，该小岛可以被雷达覆盖。</p><p>我们使用笛卡尔坐标系，定义海岸线为x轴，海的一侧在x轴上方，陆地一侧在x轴下方。</p><p>现在给出每个小岛的具体坐标以及雷达的检测范围，请你求出能够使所有小岛都被雷达覆盖所需的最小雷达数目。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入两个整数n和d，分别代表小岛数目和雷达检测范围。</p><p>接下来n行，每行输入两个整数，分别代表小岛的x，y轴坐标。</p><p>同一行数据之间用空格隔开。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，代表所需的最小雷达数目，若没有解决方案则所需数目输出“-1”。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤10001≤n≤1000</p><h4 id="输入样例：-2"><a href="#输入样例：-2" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 2</span><br><span class="line">-3 1</span><br><span class="line">2 1</span><br></pre></td></tr></table></figure><h4 id="输出样例：-2"><a href="#输出样例：-2" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>分析：通过以某个岛为圆心d为半径做圆可将二维问题转化为一维的区间问题。按终点由小到大排序，从头遍历，如果当前区间不包含最后一个选择点，就在当前区间右端创建一个新的选择点。因为只有当前区间和最后一个选择点没有交集时才会选择一个新的点，所以所选出的点以d为半径做圆，所有的圆都不会相交。因此最少选择m个点，最优解一定大于等于m，但是我们找到了答案为m的解法，所以答案就是m。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt; PDD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>  N=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-6</span>,inf=<span class="number">1e10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,r;</span><br><span class="line">PDD segs[N];</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span>(y&gt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            flag=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> len=<span class="built_in">sqrt</span>(r*r-y*y);</span><br><span class="line">        segs[i]=&#123;x+len,x-len&#125;;<span class="comment">//pair没有push直接赋值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> last=-inf;</span><br><span class="line">    <span class="keyword">if</span>(!flag)<span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sort(segs,segs+n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(segs[i].second&gt;last+eps)</span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                last=segs[i].first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="国王游戏"><a href="#国王游戏" class="headerlink" title="国王游戏"></a>国王游戏</h3><p>恰逢 H 国国庆,国王邀请 n 位大臣来玩一个有奖游戏。</p><p>首先,他让每个大臣在左、右手上面分别写下一个整数,国王自己也在左、右手上各写一个整数。</p><p>然后,让这 n 位大臣排成一排,国王站在队伍的最前面。</p><p>排好队后,所有的大臣都会获得国王奖赏的若干金币,每位大臣获得的金币数分别是:</p><p>排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数,然后向下取整得到的结果。</p><p>国王不希望某一个大臣获得特别多的奖赏,所以他想请你帮他重新安排一下队伍的顺序,使得获得奖赏最多的大臣,所获奖赏尽可能的少。</p><p>注意,国王的位置始终在队伍的最前面。</p><h4 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含一个整数 n,表示大臣的人数。</p><p>第二行包含两个整数 a 和 b,之间用一个空格隔开,分别表示国王左手和右手上的整数。</p><p>接下来 n 行,每行包含两个整数 a 和 b,之间用一个空格隔开,分别表示每个大臣左手和右手上的整数。</p><h4 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出只有一行,包含一个整数,表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。</p><h4 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤1000<br>0&lt;a,b&lt;10000</p><h4 id="输入样例：-3"><a href="#输入样例：-3" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 1</span><br><span class="line">2 3</span><br><span class="line">7 4</span><br><span class="line">4 6</span><br></pre></td></tr></table></figure><h4 id="输出样例：-3"><a href="#输出样例：-3" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>分析：从小到大排序即可。证明可以只看两个数，计算一下发现，把一对逆序的数交换后，最后的奖励一定不会增加（趋向于减小，只有当a[i]=1的时候回相等，否则就会减少），而且不会改变其他的奖励。所以只要不是排好序的就有可能变得更小，所以证得做法正确。此题难点在于高精度（这道题涉及到了高精度数*一个数，高精度数/一个数，没有涉及到高精度之间的运算）。</p><p>高精度计算vector版本:vector<int> vec(num1,num2); 表示初始化vec中有num1个num2。存取用小位在前高位在后。</int></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;贪心专题&quot;&gt;&lt;a href=&quot;#贪心专题&quot; class=&quot;headerlink&quot; title=&quot;贪心专题&quot;&gt;&lt;/a&gt;贪心专题&lt;/h1&gt;&lt;h3 id=&quot;防晒霜&quot;&gt;&lt;a href=&quot;#防晒霜&quot; class=&quot;headerlink&quot; title=&quot;防晒霜&quot;&gt;&lt;/a&gt;防晒霜&lt;/h3&gt;&lt;p&gt;有C头奶牛进行日光浴，第i头奶牛需要minSPF[i]到maxSPF[i]单位强度之间的阳光。&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://www.anjinyang.top/tags/algorithm/"/>
    
      <category term="基础算法" scheme="https://www.anjinyang.top/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
      <category term="贪心" scheme="https://www.anjinyang.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>最短Hamilton路径</title>
    <link href="https://www.anjinyang.top/2019/06/02/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B9%8B%E6%9C%80%E7%9F%ADHamilton%E8%B7%AF%E5%BE%84/"/>
    <id>https://www.anjinyang.top/2019/06/02/状态压缩位运算之最短Hamilton路径/</id>
    <published>2019-06-02T01:43:01.000Z</published>
    <updated>2019-10-16T03:05:35.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最短Hamilton路径"><a href="#最短Hamilton路径" class="headerlink" title="最短Hamilton路径"></a>最短Hamilton路径</h1><p>给定一张 n 个点的带权无向图，点从 0~n-1 标号，求起点 0 到终点 n-1 的最短Hamilton路径。 Hamilton路径的定义是从 0 到 n-1 不重不漏地经过每个点恰好一次。 <a id="more"></a> </p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入整数n。</p><p>接下来n行每行n个整数，其中第i行第j个整数表示点i到j的距离（记为a[i,j]）。</p><p>对于任意的x,y,z，数据保证 a[x,x]=0，a[x,y]=a[y,x] 并且 a[x,y]+a[y,z]&gt;=a[x,z]。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最短Hamilton路径的长度。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤20,0≤a[i,j]≤10^7</p><p>分析都在代码里了。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二进制0和1表示存在不存在，状态压缩</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">20</span>,M=<span class="number">1</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> f[M][N],weight[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;weight[i][j];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> f);<span class="comment">//(初始化为正无穷)地址f，大小sizeof f,初始化为0x3f</span></span><br><span class="line">    </span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//已经走过的点有0，现在在0位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span>(i&gt;&gt;j&amp;<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">                    <span class="keyword">if</span>(i-(<span class="number">1</span>&lt;&lt;j)&gt;&gt;k&amp;<span class="number">1</span>)</span><br><span class="line">                        f[i][j]=min(f[i][j],f[i-(<span class="number">1</span>&lt;&lt;j)][k]+weight[k][j]);<span class="comment">//f[i][j]=min(f[i][j],f[这里第一次写错了][k]+weight[k][j])</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>][n<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//for中定义的i在这里不能用所以写成1&lt;&lt;n，最后还忘了加括号，减号优先级高于移位运算符</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;最短Hamilton路径&quot;&gt;&lt;a href=&quot;#最短Hamilton路径&quot; class=&quot;headerlink&quot; title=&quot;最短Hamilton路径&quot;&gt;&lt;/a&gt;最短Hamilton路径&lt;/h1&gt;&lt;p&gt;给定一张 n 个点的带权无向图，点从 0~n-1 标号，求起点 0 到终点 n-1 的最短Hamilton路径。 Hamilton路径的定义是从 0 到 n-1 不重不漏地经过每个点恰好一次。&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://www.anjinyang.top/tags/algorithm/"/>
    
      <category term="状态压缩" scheme="https://www.anjinyang.top/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
      <category term="递归" scheme="https://www.anjinyang.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>web小测复习</title>
    <link href="https://www.anjinyang.top/2019/04/14/web%E5%B0%8F%E6%B5%8B%E5%A4%8D%E4%B9%A0/"/>
    <id>https://www.anjinyang.top/2019/04/14/web小测复习/</id>
    <published>2019-04-13T16:00:00.000Z</published>
    <updated>2019-10-16T03:05:45.458Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2019-4-13web小测复习"><a href="#2019-4-13web小测复习" class="headerlink" title="2019.4.13web小测复习"></a>2019.4.13web小测复习</h3><h4 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h4><ul><li><p>web相关概念</p></li><li><p>了解web领域</p></li><li><p>B/S架构</p></li><li><p>学习方法</p><a id="more"></a> </li></ul><p>万维网：（亦作“Web”、“WWW”、全称为“World  Wide Web”），是一个由许多互相链接的超文本组成的系统，通过互联网访问。</p><p>URL</p><ul><li>Uniform Resource Locator 统一资源定位符</li><li>组成部分：协议、服务器地址（域名）、资源路径</li></ul><p>B/S架构（Browser/Server）</p><ul><li>通过浏览器访问的网络应用程序。</li><li>典型应用：<ul><li>师大官网、网页版微博、网页版京东 …</li></ul></li><li>特点：无缝升级、客户端免维护；不能直接使用客户端硬件资源，用户体验单一</li></ul><p>C/S架构（Client/Server）</p><ul><li>通过客户端应用软件访问的网络应用程序。</li><li>典型应用：<ul><li>淘宝、QQ、微信 …</li></ul></li><li>特点：能直接使用客户端硬件资源；需要安装特定客户端程序、针对不同平台开发不同版本、升级应用须重新安装。</li></ul><p><img src="/2019/04/14/web小测复习/img/article/1555121152235.png" alt></p><h4 id="第二章-html基础"><a href="#第二章-html基础" class="headerlink" title="第二章 html基础"></a>第二章 html基础</h4><ul><li><p>理解网页文件</p></li><li><p>掌握html语法基础</p></li><li><p>html常用标签</p></li></ul><p>什么是网页？什么是网页文件？</p><ul><li><p>网页是构成网站的基本元素，是承载各种网站应用的平台，实质就是一个网页文件。</p></li><li><p>网页文件就是文本文件，扩展名为 .html 或 .htm，文件内容为 HTML 代码和文本内容</p></li></ul><p>访问网页的过程？</p><ol><li>通过输入网址（[URL][Uniform Resource Locator 统一资源定位符]）指定要访问的网页</li><li>请求：向服务器（server）发送请求，把XXX网页文件传送给我</li><li>响应：服务器发出响应，把XXX网页文件传送给你</li><li>浏览器(browser)“解释”网页文件，呈现出网页</li></ol><p>单双标签作用？</p><ul><li>单标签：在开始标签中进行关闭，无需表达范围，仅在标签出现处有效</li><li>双标签：由“开始标签”和“结束标签”两部分构成。必须成对使用。 代表标签作用范围</li></ul><p>HTML:Hyper Text Markuo Language</p><ul><li>超文本标记语言</li><li>HTML不是编程语言，是一种标记语言</li><li>标记语言是一套标记标签，HTML用标记标签来描述网页</li><li>三个要点：词汇、语法、语义</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span>:HTML文档声明</span><br></pre></td></tr></table></figure><p>用法：放在文件开头 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span>：HTML（网页）文件开始及结束</span><br></pre></td></tr></table></figure><p>用法：成对出现、分别位于文件的开始和结束位置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span>：指明网页文件的头部</span><br></pre></td></tr></table></figure><p>用法：成对出现、嵌套于 html 标签内、位于 body 标签之上</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> /&gt;</span>：定义页面有关信息，如页面编码、关键词、页面描述</span><br></pre></td></tr></table></figure><p>用法：单标签，必须在 head 标签内、利用属性值进行设置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span> <span class="tag">&lt;/<span class="name">title</span>&gt;</span>：在浏览器标题栏显示的文档标题</span><br></pre></td></tr></table></figure><p>用法：成对出现、嵌套于 head 标签内</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span>：指明网页文件体部</span><br></pre></td></tr></table></figure><p>用法：成对出现、嵌套于 html 标签内、位于 head 标签之下</p><p>HTML 元素：从开始标签到结束标签的所有代码。</p><p>书写规范</p><ul><li>标签可以嵌套的，但先后书序必须保持一致</li><li>标签对大小写不敏感，同意建议小写</li></ul><p>标签属性</p><ul><li>书写形式： NAME = “VALUE”</li><li>位置：开始标签</li><li>不同标签有不同属性</li></ul><p>标题标签：h1-h6</p><p>段落标签：p ，p元素会自动在其前后创建一些空白</p><p>图片标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>属性：</p><ul><li>路径 src:相对路径、绝对路径</li><li>alt:当图片无法加载显示的替换文本</li></ul><p>绝对路径：从盘符开始的完整路径。</p><p>相对路径：指相对当前文件或目录的路径。</p><p>相对路径规则：</p><ul><li>图片和网页在同级目录     src=”<strong>./</strong>图片名”</li><li>图片在网页的下一级目录  src=”目录名称<strong>/</strong>图片名”</li><li>图片在网页的上一级目录 src=”<strong>../</strong>图片名”</li></ul><p>超链接</p><ul><li><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>……<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>href：必选属性，规定连接目标</p></li><li><p>target:_blank新窗口打开， _self当前窗口打开（默认）</p></li></ul><p>无需列表和有序列表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">无序列表使用<span class="tag">&lt;<span class="name">ul</span>&gt;</span> 标签， 每个列表项使用 <span class="tag">&lt;<span class="name">li</span>&gt;</span>标签</span><br><span class="line">有序列表使用 <span class="tag">&lt;<span class="name">ol</span>&gt;</span> 标签，每个列表项使用 <span class="tag">&lt;<span class="name">li</span>&gt;</span>标签</span><br></pre></td></tr></table></figure><p>注意事项</p><ul><li>文件的扩展名要以 .html 或者 .htm 结束。</li><li>文件名由英文字母、数字或下划线组成。</li><li>文件名中不要包含特殊符号，比如空格、$ 等，不使用中文。</li></ul><h4 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h4><ul><li><p>表格</p></li><li><p>表单</p></li></ul><h5 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">""</span>&gt;</span> <span class="tag">&lt;/<span class="name">table</span>&gt;</span>定义一个表格</span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span> 定义表格中一行，嵌套于table内</span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span> <span class="tag">&lt;/<span class="name">th</span>&gt;</span>定义表头，嵌套于tr内</span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">td</span>&gt;</span>定义单元格，嵌套于tr内</span><br></pre></td></tr></table></figure><p>相关属性：</p><ul><li>border：        表格边框的宽度（pixels）</li><li>bordercolor：表格边框的颜色</li><li>background：表格背景图</li><li>bgcolor：       表格背景颜色</li><li>cellpadding :  单元边沿与其内容之间的距离（pixels）</li><li>cellspacing :   单元格之间的空白（pixels）</li><li>width :      规定表格元素的宽度（pixels或%）</li><li>height :     规定表格元素的高度（pixels或%）</li><li>align：      表格的对齐方式（left  center  right）</li></ul><p><img src="/2019/04/14/web小测复习/img/article/cell.png" alt="cell"></p><p>单元格合并：</p><ul><li>colspan:某行列合并</li><li>rowspan:某列行合并</li></ul><h5 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h5><p>表单是一个包含表单元素的区域。表单元素是允许用户在表单中输入信息的元素。（比如：文本框、下拉列表、单选框、复选框等等）</p><p>其作用是从访问网站的用户那里获得信息，是用户向服务器传输数据的接口。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">method</span>=<span class="string">""</span>&gt;</span> <span class="tag">&lt;/<span class="name">form</span>&gt;</span>定义一个表单</span><br></pre></td></tr></table></figure><p>相关属性：<br>action：   规定向何处发送提交的表单数据。值：URL<br>method：规定以何种方式将表单数据传送到服务器。值：get/post</p><p>Get</p><ul><li>URL 改变，在URL 里显示 HTML Form 参数的 name/value 值。</li><li>只适合有少量参数的 HTML Form，因为 URL 长度有字符限制，不能无限长。</li><li>涉及安全性的信息，比如用户密码，不能用 get，因为会在 URL 上显示，不安全。</li></ul><p>Post</p><ul><li>URL 不改变，不在 URL 里显示 HTML Form 的数据。</li><li>Form 提交的信息没有长度限制。</li><li>涉及安全性的信息，如用户密码，应采用 post 方式。</li></ul><p>表单控件input标签</p><p>文本框：当用户要在表单中输入字母、数字等时，用到文本框</p><ul><li>type：当type = “text”时，输入框为文本输入框。</li><li>name：为输入框命名，以备后台程序使用。</li><li>value：为输入框设置默认值。(一般起到提示作用)</li></ul><p>密码框</p><ul><li>type=”password”</li></ul><p>单选框</p><ul><li>type=”radio” 添加checked默认选中</li></ul><p>复选框</p><ul><li>type=”checkbox”添加checked默认选中</li></ul><p>文件控件</p><ul><li>type=”file”</li></ul><p>按钮</p><ul><li>提交按钮 type=”submit”</li><li>重置按钮 type=”reset”</li><li>普通按钮 type=”button”</li></ul><p>一组单选框或一组多选框中每个input标签的name属性为什么必须要有相同取值？</p><p>同组单选框/复选框name属性值必须相同，是为了将其归为同一组，提交数据时作为一组数据进行提交。这样同组单选框才可以起到单选作用，复选框可识别为同一问题的多个选择。</p><p>表单控件<textarea>多行文本域</textarea></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">rows</span>=<span class="string">""</span> <span class="attr">cols</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>相关属性</p><p>rows：规定文本区可见行数</p><p>cols：规定文本区可见列数</p><p>表单控件<select>下拉列表</select></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>lable标签</p><p><label for="控件id名称"> 用户名：</label><br><input type="text" id="id名称"></p><p>当鼠标点击“用户名：”时，所关联的控件会获得焦点。</p><ul><li>label 元素不会向用户呈现任何特殊效果，它只是增加了用户体验。</li><li>点击 label 元素内文本，就会触发此控件。即当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</li></ul><p>热区相关代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span> = <span class="string">"planets.jpg"</span> <span class="attr">usemap</span> = <span class="string">"#planetmap"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span> = <span class="string">"planetmap"</span> <span class="attr">id</span> = <span class="string">"planetmap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span> = <span class="string">"circle"</span> <span class="attr">coords</span> = <span class="string">"180,139,14"</span> <span class="attr">href</span> = <span class="string">"venus.html"</span> <span class="attr">alt</span> = <span class="string">"Venus"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span> = <span class="string">"rect"</span>  <span class="attr">coords</span> = <span class="string">"0,0,110,260"</span> <span class="attr">href</span> = <span class="string">"sun.html"</span> <span class="attr">alt</span> = <span class="string">"Sun"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span>   <span class="attr">src</span>=<span class="string">""</span>  <span class="attr">usemap</span>=<span class="string">"**#**名称"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span>&gt;</span>  name="名称” id="名称"&gt;<span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure><p>map 中的 id 属性和 name 属性设置为相同，与 img /标签的usemap 属性匹配，创建图像与映射之间的联系。</p><p><strong><area></strong> —— 定义图像映射中的区域</p><ul><li>alt：替代文本</li><li>href：该区域的链接地址</li><li>shape：该区域的形状（rect：矩形  circle：圆形  poly：多边形）</li><li>coords：该区域在原始图片上的坐标值</li></ul><p>内联框架</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>相关属性</p><ul><li>src：文件的路径</li><li>width、height：“内联框架”区域的宽与高</li><li>name：框架的名字，用来识别框架</li><li>frameBorder：设置是否显示框架的边框，值为 1 或者 0</li><li>scrolling：当 src 的指定的HTML文件在指定的区域显示不完时，滚动选项：no（不出现滚动） /  yes（显示滚动）  /  auto（自动出现滚动条）</li></ul><h4 id="第四章-CSS开发基础"><a href="#第四章-CSS开发基础" class="headerlink" title="第四章 CSS开发基础"></a>第四章 CSS开发基础</h4><p><strong>CSS</strong> 是 <strong>Cascading Style Sheet</strong> 的缩写。译作「层叠<strong>样式表</strong>」。</p><p>CSS 是用于(增强)控制网页样式并允许将样式与网页内容<strong>分离</strong>的一种样式表语言。</p><p>CSS代码是由一条条语句构成，而每一条语句的结构，都基本相同</p><ul><li>选择器 {属性：属性值；属性：属性值;……}</li></ul><p>三类选择器</p><ul><li>标签选择器</li><li>类选择器</li><li>id选择器</li></ul><h6 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h6><p>直接以某类标签为选择器后加{属性：属性值；}</p><ol><li>标签选择器在什么情况下使用？<ul><li>控制某一类标签时</li></ul></li><li>标签选择器的优势？<ul><li>简便快速</li></ul></li><li>标签选择器的劣势？<ul><li>这类标签在需要区分的时候无法区分</li></ul></li></ol><h6 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h6><p>以 . 开头定义的选择器，影响所有以class属性引用该类的标签样式。类名的第一个字符不能使用数字和特殊字符。</p><h6 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h6><p>以 # 开头定义的选择器，影响以id属性引用该选择符的标签样式，id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。同一id 属性值只能在 HTML 文档中出现一次。</p><p>从内容中抽离出来的 CSS 样式，应如何与 HTML 内容进行整合使之生效呢？</p><ul><li>行内样式：标签内通过 style 属性添加样式。（style=”属性：属性值; “）用途：指定网页中个别元素的显示效果。不符合样式与内容分离原则，不推荐使用。</li><li>页内样式:在 head 部分的 style 标签内添加样式。用途：对页面中某些标签或元素设置样式风格。控制当前页面样式，维护较困难。</li><li>外部样式：引用外部建立的 .css 文件。用途：可同时控制多个页面。适用于各类大型网站，可用性最强，推荐使用。</li></ul><p>样式优先级：</p><ul><li>ID选择器 &gt; 类选择器 &gt; 标签选择器</li><li>行内样式 &gt; 页内样式 &gt; 外部样式</li><li>就近原则，距离元素最近的样式优先级最高</li></ul><p>lCSS 样式的叠加</p><ul><li>多个样式，在同一内容上共同实现，叫做 CSS 样式的叠加。</li></ul><p>lCSS 样式的可继承性</p><ul><li>文档中的某些元素，将沿用为其父元素所设想置的样式，这种特点叫做 CSS样式的可继承性。</li></ul><p>CSS注释方法：/* */</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;2019-4-13web小测复习&quot;&gt;&lt;a href=&quot;#2019-4-13web小测复习&quot; class=&quot;headerlink&quot; title=&quot;2019.4.13web小测复习&quot;&gt;&lt;/a&gt;2019.4.13web小测复习&lt;/h3&gt;&lt;h4 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;web相关概念&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;了解web领域&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;B/S架构&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;学习方法&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="html" scheme="https://www.anjinyang.top/tags/html/"/>
    
      <category term="CSS" scheme="https://www.anjinyang.top/tags/CSS/"/>
    
      <category term="web" scheme="https://www.anjinyang.top/tags/web/"/>
    
      <category term="计算机基础知识" scheme="https://www.anjinyang.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>导论复习</title>
    <link href="https://www.anjinyang.top/2019/01/07/%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0/"/>
    <id>https://www.anjinyang.top/2019/01/07/导论复习/</id>
    <published>2019-01-06T16:00:00.000Z</published>
    <updated>2019-10-16T03:04:26.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><ul><li><p>什么是计算机（定义），了解按运算方式分，今天用的大多数是数字计算机（按大小，是微机；大小指CPU的运算速度）</p></li><li><p>计算机由硬件和软件组成。 <a id="more"></a> </p><ul><li>硬件分为主机和外设<ul><li>主机分为CPU和内存<ul><li>CPU分为运算器和控制器</li></ul></li><li>外设有I/O设备（I/O如何区分以内存为参照物）</li></ul></li><li>软件分为系统软件和应用软件（另一种说法，分为程序和文档）</li></ul></li><li><p>内存结构</p></li><li><p>冯诺依曼计算机体系（三句话）</p><ol><li>计算机由运算器、控制器、存储器、输入设备、输出设备组成</li><li>数据和程序在计算机中以0/1的形式存在</li><li>程序应该存储在内存中</li></ol></li><li><p>计算机性能指标</p><ul><li>运算速率等</li></ul></li><li><p>巨型化（巨指运算速度）、微型化（微指体积）、网络化</p></li></ul><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>考试考进制转换/<strong><u>二四译码器（考画图，我还不会）</u></strong>/原反补码</p><p>先看看几位存数（例，7为存储数字，有一位是符号位，存储数字的绝对值的用6位）。x=3如何到内存中，编译产生地址，二四译码器寻址打开对应地址的内存，不同字节的相对的位都连在数据线上，3流经数据线，只有对应地址的内存打开，3就进去了。</p><p><strong>（不要掉以轻心，认真检查，一定要冷静）</strong></p><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><p>python</p><p>斐波那契数列和水仙花数<strong>（用心读题，考其中一个，不用心读题就惨了）</strong></p><p>低级语言计算机容易理解，高级语言人容易理解。</p><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><p>程序设计导引。</p><ul><li><p>常见的数据结构：线性表、栈（1234入可以1234也可以4321出）、队列（先进先出）、二叉树、链表、图。</p></li><li><p>两种设计方法：面向过程，面向对象（尽量模拟现实世界中人的思维进行软件开发）。</p></li><li><p>软件：程序和文档。</p></li><li><p><strong><u>软件生命周期</u></strong>。<strong>（重要）</strong></p></li></ul><p>（可行性分析-需求分析-概要设计-详细设计-编码-调试-运行-维护）</p><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><p>操作系统内存管理不考（硬件管理只讲了内存管理）。</p><p>什么是操作系统（是控制和管理计算机系统内各种硬件和软件资源、合理有效地组织计算机系统的工作，为用户提供一个使用方便可扩展的工作环境，从而起到连接计算机和用户的接口作用）</p><p>操作系统分为批处理操作系统、分时操作系统、实时操作系统、嵌入式操作系统</p><p>补充（进程：正在运行的程序。进程的特征：进程实体=pcb+程序+数据）</p><ol><li>进程如何刻画：进程控制块（pcb）<ul><li>进程控制块是描述进程的基本数据结构</li></ul></li><li>进程的四个特征：动态性（进程：进程实体的一次执行过程，有生命周期。程序：程序是一组有序指令的集合，是静态的概念。）、并发性、独立性（同一个程序多个进程的内容不一样）、异步性。<strong>（记住）</strong></li><li>进程的三状态：运行（正在执行）、就绪（其他资源万事俱备只差cpu）、阻塞（等待资源没有运行，不只是等待内存）</li><li>进程三状态转换。<strong>（记住）</strong><img src="/2019/01/07/导论复习/F:%5C%E6%96%B0%E6%AF%94%E5%B0%94%E7%9B%96%E8%8C%A8%E7%9A%84%E5%AE%9D%E8%97%8F%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E4%BA%A4%E5%8F%89%E4%BF%A1%E6%81%AF%E7%A0%94%E7%A9%B6%E9%99%A2%E4%B8%8A%E6%B5%B7%E4%BA%A4%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E9%99%A2%5C%E5%AD%A6%E4%B9%A0%5C%E8%80%83%E8%AF%95%5C%E5%A4%8D%E4%B9%A0%5C%E8%BF%9B%E7%A8%8B%E4%B8%89%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" alt></li></ol><p>CPU调度：抢占（到一定时间看执行谁）/不抢占<strong>【会计算周转时间】</strong></p><h2 id="网络和数据库自行复习"><a href="#网络和数据库自行复习" class="headerlink" title="网络和数据库自行复习"></a>网络和数据库自行复习</h2><p>网络</p><ul><li>网络分层有利于提高工作效率和容错性，增强网络的可扩展性。<ul><li>物理层解决如何在连接各种计算机的传输媒体上传输数据比特流<ul><li>信道复用<ul><li>时分复用：时分复用的所有用户是在不同的时间占用同样的频带宽度</li><li>频分复用：频分复用的所有用户在同样的时间占用不同的带宽资源</li></ul></li></ul></li><li>数据链路层：封装成帧，透明传输，差错检测（比特差错）<strong>[基本]</strong></li><li>网络层：找到对方计算机在网络中的位置（IP地址），然后把数据传输给他。网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。（发送分组无序）<ul><li>子网掩码：将某个IP地址划分成网络地址和主机地址两部分。</li><li>默认网关：<em>一个用于 TCP/IP 协议的配置项，是一个可直接到达的 IP 路由器的 IP 地址。</em></li><li>IP地址</li></ul></li><li>传输层：实现应用程序到应用程序的连接和信息的切分和重组（因为网络层无序，所以接受数据的计算机传输层就需要重组，因为网络层按组传输，所以发送数据的计算机的传输层需要切分，分组）<ul><li>通过端口区分进程</li><li>用户数据报协议UDP（无连接）</li><li>传输控制协议TCP（连接、三次握手）<ul><li>三次握手协议：建立连接、传输数据、释放链接三个步骤。三次握手目的：在不可靠的网络中建立一种可靠的传输方式。三次握手是一种建立连接的方式如下：<ul><li>计算机A：SYN=1，X</li><li>SYN=1所以计算机B知道要A想建立连接，计算机B：SYN=1，ACK=1，X+1，Y</li><li>计算机A检查X+1和ACK是否等于1，若都正确，计算机A：ACK=1，Y+1。计算机B收到后检查Y+1和ACK是否为1后成功建立连接。</li></ul></li></ul></li></ul></li><li>应用层：应用层协议都是为了解决某一类实际应用问题。（应用层针对不同的应用程序设计了不同的应用层协议，这些协议将信息按某种规则、格式进行规范化描述，再通过统一标准化的接口与传输层进行对接。）</li></ul></li><li><strong>消息首先在传输层被切割成多个部分，每一部分都传送到网络中，网络层给每个数据包添加一个头部和尾部，包含了传输目的地的IP地址等信息，紧接着，数据包又被传送到了数据链路层，数据链路层又给数据包加上一个头部和尾部，其中包括了差错校验的信息。最终到物理层转化成01串。</strong>大的互联网是由一个个小网络的路由器组成。发送到对方计算机后，数据链路层出去头部尾部，网络层去掉头部尾部，传输层将多个数据包合成一个数据消息，找到应用程序，传给应用层，最终在对方应用程序中显示消息。</li><li>数据链路层只负责检测，传输层的差错控制可以实现纠错。</li><li>URL（统一资源定位符）：协议+域名+资源路径</li><li>访问一个网页的过程：<ul><li>在计算机上的客户端浏览器上输入百度的网址；</li><li>通过DNS获得这个域名相应的IP地址；</li><li>获得IP地址后，向储存有网页的服务器发出访问请求，服务器接收到了访问请求后在自己的域名下寻找相应的网页；</li><li>服务器找到所请求的网页后，向客户端浏览器上发送一些信息；</li><li>客户端浏览器收到这些信息后，依据这些返回的信息组织成可以查看的网页。</li></ul></li></ul><p>数据库</p><p>关系（relation）—表//元组(tuple)—行//属性(arrtribute)—列</p><p>相关概念</p><ul><li><p>候选码：若关系中的某一属性组的值能唯一地表示一个元组，而其子集不能，则称该属性组为候选码</p></li><li><p><strong>主码：</strong>若一个关系有多个候选码，则选定其中一个为主码<strong>（主码能唯一确定一个元组）</strong></p></li><li><p>主属性：候选码的诸属性称为主属性</p></li><li><p>非主属性：不包含在任何候选码中的属性称为非主属性</p></li><li><p>全码：在最极端的情况下，关系模式的所有属性是这个关系模式的候选码</p></li></ul><p>三类完整性约束：</p><ul><li><p>实体完整性：主属性非空。</p></li><li><p>参照完整性：限定外码的取值为所参照主码的值或者NULL。（选课表作为学生表和课程表的桥梁，CREAT是要作参照说明，参照的学生学号和课程编号必须分别真实存在于学生表和课程表中）</p></li><li><p>用户自定义完整性：不同的关系数据库系统根据其应用环境的不同，往往需要一些特殊的约束条件，是用户根据需求针对某一具体关系数据库的约束。比如性别取值为“男”或“女”。</p></li></ul><p>增删查改</p><ul><li><p>数据库的创建、使用、删除</p><ul><li>CREAT DATEBASE Software Institute;</li><li>USE Software Institute;</li><li>DROP Software Institute;</li></ul></li><li><p>关系的创建、删除，数据的插入、删除、修改、查询</p><ul><li><p>CREAT TABLE Students(id string [列完整性约束],name string,sex,age int……);</p></li><li><p>DROP TABLE Students;</p></li><li><p>INSERT INTO Students(可以只添加某些列的值，也可以全添加)</p><p>VALUES(xx,xxx,……);</p></li><li><p>DELETE FROM Students</p><p>WHERE ……;</p></li><li><p>UPDATE Students</p><p>SET password=’123456’</p><p>WHERE id=’2018000000’;</p></li><li><p>SELECT *(星号代表所有信息，也可以只查某些信息)</p><p>FROM Students</p><p>WHERE id=’2018000000’;</p></li><li><p><strong>期末考试要考察的NULL</strong>(随便举例，NULL代表空，不确定的值)</p><p>SELECT *</p><p>FROM Students</p><p>WHERE grades=NULL;</p></li></ul></li></ul><p>ER图（矩形代表关系，圆矩代表属性，菱形代表联系）属于概念结构设计。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;什么是计算机（定义），了解按运算方式分，今天用的大多数是数字计算机（按大小，是微机；大小指CPU的运算速度）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;计算机由硬件和软件组成。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="计算机基础知识" scheme="https://www.anjinyang.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="计算机导论" scheme="https://www.anjinyang.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
</feed>
