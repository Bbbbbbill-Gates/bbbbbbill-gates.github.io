<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>好喜欢胖鱼啊啊啊啊啊啊啊</title>
  
  <subtitle>Coding changes the world</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.anjinyang.top/"/>
  <updated>2019-10-16T11:25:08.013Z</updated>
  <id>https://www.anjinyang.top/</id>
  
  <author>
    <name>ajy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为什么面向对象糟透了</title>
    <link href="https://www.anjinyang.top/2019/10/16/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B3%9F%E9%80%8F%E4%BA%86/"/>
    <id>https://www.anjinyang.top/2019/10/16/为什么面向对象糟透了/</id>
    <published>2019-10-16T11:10:45.000Z</published>
    <updated>2019-10-16T11:25:08.013Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一"><a href="#一" class="headerlink" title="一"></a>一</h3><p>又是周末，编程语言“三巨头”Java, Lisp 和C语言在Hello World咖啡馆聚会。</p><p>服务员送来咖啡的同时还带来了一张今天的报纸， 三人寒暄了几句， C语言翻开了报纸，突然眼前一亮：“这篇文章的标题写得好啊， 《为什么面向对象糟透了！》”</p><p>(这是一篇很早之前的文章，作者是大名鼎鼎的Joe Armstrong ， 也就是Erlang之父。)</p><p>Java 大吃一惊，居然有人这么骂面向对象？！</p><p>他赶紧抢过来，看了一会儿，说到：“虽然我对去世的Joe Armstrong老先生非常尊敬，但是我对他的观点却不敢苟同，你看他说’<strong>数据结构和函数不应该绑到一起</strong>！’”</p><p>C语言说：“他说得很有道理啊，函数是实现算法的，就像一个黑盒子，只要理解了它的输入和输出，就理解了它的功能，而数据结构呢就是单纯的‘声明’，为什么要把他们绑在一起呢？”</p><p>“不不不，还是绑在一起好！我给你举个例子，一个栈，如果你把它当成一个完整的对象，那用起来就方便多了。”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stack s = new Stack();</span><br><span class="line"></span><br><span class="line">s.push(100);</span><br><span class="line"></span><br><span class="line">s.push(200);</span><br><span class="line"></span><br><span class="line">s.pop();</span><br></pre></td></tr></table></figure><p>C语言不甘示弱：“把数据结构和函数分开也挺好啊！比如我可以创建一个叫做Stack的数据结构，然后写几个对这个数据结构操作的函数。”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push(stack, 100);</span><br><span class="line"></span><br><span class="line">push(stack, 200);</span><br><span class="line"></span><br><span class="line">pop(stack);</span><br></pre></td></tr></table></figure><p>Java不屑一顾地说：“你看看你这种方式多丑陋啊。”</p><p>C语言寸步不让：“本质都是一样的，你是o.f() ，我是f(o)，  有啥区别？”</p><p>Lisp也插了一嘴：“还有我的(f o) ”</p><h3 id="二"><a href="#二" class="headerlink" title="二"></a>二</h3><p>Java无语，心说这两个家伙就是胡搅蛮缠。突然，他心中一动：我怎么忘记多态了。</p><p>Java说：“本质是不一样的，你要知道，o.f()是可以产生多态行为的，这就带来了巨大的好处，我给你举个例子，你有一段业务逻辑，需要把计算的结果记录到文件中，将来还可能会记录别的地方，你的设计可能是这样的。”</p><p><img src="/2019/10/16/为什么面向对象糟透了/pic1.jpg" alt="pic1"></p><p>C语言：“难道不应该如此吗？一个函数调用另外一个函数？”</p><p>Java 说到：“这里有个依赖的问题，就是businessLogic()不但运行期依赖writeToFile(), 在源码级或者编译期也会依赖。”</p><p>C语言：“这不是很正常嘛！”</p><p>Java又说道：“不一样， 写入文件是底层的实现细节，不是高层策略，假如用户不想把计算的结果保存到文件中了，而是想通过邮件发送，那你的businessLogic也得修改了，对不对？”</p><p><img src="/2019/10/16/为什么面向对象糟透了/pic2.jpg" alt="pic2"></p><p>C语言：“那肯定啊！函数调用嘛，一个改了，另外一个也得改。”</p><p>“这就是问题了， 编译期/源代码的依赖导致我们没法把系统划分成独立的组件，各自独立开发，独立部署，一个的变化就影响到了另外一个。”</p><p>C语言觉得有一定的道理，他说：“那怎么办？”</p><p>Java说：“你看看我使用多态以后的设计，<strong>我的业务逻辑在编译时只依赖那个接口Writer</strong>，而不依赖具体的实现FileWriter和MailWriter。”</p><p><img src="/2019/10/16/为什么面向对象糟透了/pic3.jpg" alt="pic3"></p><p>“你的意思是只要接口Writer不变化，底层的具体实现如FileWriter ,MailWriter可以随意变化，随意替换，就像插件一样，对吧？”  C语言说到。</p><p>“对啊，编译期/源代码不依赖，运行期依赖，这就是延迟绑定带来的好处，现在你明白o.f()和 f(o)的本质区别了吧。 ”</p><p>Lisp 不失时机又插了一嘴：“你那接口中只有一个函数，就是write()，用什么接口啊，脱裤子放屁，多此一举，在我这儿只要把不同的函数传递过去就可以了。”</p><p>Java笑道：“别抬杠，这就是个简单的例子，不管是用接口，还是传递函数，都是延迟绑定嘛， 关键点都是要找到那个稳定的东西（Writer），就是抽象。你找不到这个稳定的东西，做不出抽象，你的系统就没法划分成可以独立开发，独立变化的组件了。”</p><p>C语言还想反击，但一直找不到突破口。</p><p>Lisp说道：“别听Java在哪里忽悠，C老弟，你也能实现运行期的延迟绑定，这不是Java的专利，你忘了虚函数表了？”</p><p>C语言一拍大腿：“是啊，我忘了那一年春节回家，Linus 大神曾经告诉我，虚函数表和函数指针才是实现多态的关键，比如Unix/Linux把设备都当成了文件，有标准的open , read 等方法，对于不同的设备，都能调用对应的方法， 那是怎么实现的？也是通过虚函数表做延迟绑定嘛！”</p><p>（码农翻身老刘注：C语言实现面向对象的详情可以移步《</p><p>C语言高兴了：“哈哈，Java 老弟，看来我们本质上还是一样的，多态只不过是函数指针的一种应用！”</p><p>Java说：“所以编程的关键不在于是否使用了面向对象的语言，这一点你同意吧？”</p><p>C语言点头，编程的关键点就是找到、抽象出稳定的接口，针对这个接口编程，这样就可以让各个模块能够独立地变化。</p><h3 id="三"><a href="#三" class="headerlink" title="三"></a>三</h3><p>“说起来容易，做起来难，这儿有一个例子，你给我用面向对象设计一下？”  Lisp 抛出了一道题。</p><p>动物可以分为肉食动物，草食动物，水生动物，陆生动物，用类如何表示？</p><p>Java 说：这还不简单，看看这名词多明显啊，都可以变成类啊，让他们都继承动物就可以了。</p><p><img src="/2019/10/16/为什么面向对象糟透了/pic4.jpg" alt="pic4"></p><p>Lisp看到Java 掉入了陷阱，狡黠地一笑：“那有的动物就既是陆生动物，又是肉食动物，怎么表达？”</p><p>“那我就加一个陆生肉食动物类。” 虽然觉得不妥，Java还是说了出来。</p><p><img src="/2019/10/16/为什么面向对象糟透了/pic5.jpg" alt="pic5"></p><p>“那要是再来一个水生肉食动物怎么办？或者来了一个新的概念‘哺乳动物’， 该怎么处理？”</p><p>“哈哈哈，我懂了，随着需求的增多，不但类会出现爆炸， 还可能会出现那种怪异的类，这面向对象编程确实是有大问题啊！”  C语言说。</p><p>Java 低头沉思不语，突然，脑海中想起来了那句话：优先使用组合而不是继承。</p><p>怎么使用组合？必须得改变下看待问题的方式，对，应该这样：</p><p><img src="/2019/10/16/为什么面向对象糟透了/pic6.jpg" alt="pic6"></p><p>Java得意地说：“看看这个图， 动物具备多个特性，如’进食’, ‘移动’，将来还可以加上’哺乳方式’，<strong>每个特性都是一个接口，接口是稳定的， 动物这个概念是可以通过这些接口特性给组合起来的</strong>。”</p><p>Lisp 赞赏地点头， C语言向Java投去了钦佩的目光，这家伙经常做面向对象的设计，还是有两把刷子的，他通过特性的方式把变化给隔离了， 各个特性可以通过组合的方式，像插件一样随意替换， 嗯，这才是面向对象的真正精髓啊。</p><p>夜已深， 最后Java做了个总结，大伙散去。</p><p>“编程嘛就是发现变化，并且把它给隔离起来，使用各种语言都可以，面向对象的语言有着直接使用多态的便利，以后不要随随便便就diss它了。”<br>————————————————</p><p><em>原文链接：<a href="https://blog.csdn.net/coderising/article/details/101444370" target="_blank" rel="noopener">https://blog.csdn.net/coderising/article/details/101444370</a></em></p><h3 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h3><p>无论是面向过程，还是面向对象，无论是什么语言，各有其优劣。最重要的不是会什么语言，而是学会抽象解决问题的方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一&quot;&gt;&lt;a href=&quot;#一&quot; class=&quot;headerlink&quot; title=&quot;一&quot;&gt;&lt;/a&gt;一&lt;/h3&gt;&lt;p&gt;又是周末，编程语言“三巨头”Java, Lisp 和C语言在Hello World咖啡馆聚会。&lt;/p&gt;
&lt;p&gt;服务员送来咖啡的同时还带来了一张今天的
      
    
    </summary>
    
    
      <category term="行业" scheme="https://www.anjinyang.top/tags/%E8%A1%8C%E4%B8%9A/"/>
    
      <category term="编程语言" scheme="https://www.anjinyang.top/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="面向对象" scheme="https://www.anjinyang.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="面向过程" scheme="https://www.anjinyang.top/tags/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>中国互联网激荡20年</title>
    <link href="https://www.anjinyang.top/2019/10/16/%E4%B8%AD%E5%9B%BD%E4%BA%92%E8%81%94%E7%BD%91%E6%BF%80%E8%8D%A120%E5%B9%B4/"/>
    <id>https://www.anjinyang.top/2019/10/16/中国互联网激荡20年/</id>
    <published>2019-10-16T03:32:06.000Z</published>
    <updated>2019-10-16T03:36:58.880Z</updated>
    
    <content type="html"><![CDATA[<p>故事还要从24年前那个夏天说起。</p><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>1995年的夏天，美国西海岸有一个中年人出版了一本叫《未来之路》的书籍，这本书是大家了解信息高速公路全部面目乃至21世纪人类生活面貌的入门书。在这本书中，这个中年人多次提到“物物互联”的设想。但是由于当时网络技术与传感器应用水平的限制，中年人朦胧的“物联网”理念没有引起重视。对了，这个中年人后面做了十几次世界首富！ <a id="more"></a> </p><p>说回国内，那时风还没有起来，科技的土囊很贫瘠，更别提物联网了。1995年，大家还在积极看电视。</p><p>那年电视上映了一部叫《海尔兄弟》的动画片，主要讲述一对由智慧老人所创造的海尔兄弟和他们的朋友，为解决人类面临的灾难和解开无尽的自然之谜而环游世界，最后回到他们的诞生地太平洋的神奇历险故事。该部动画片通过描述海尔兄弟的探险经历，向人们传递了科学与人文知识。</p><p>那年电视上出现了一档采访，杭州西湖明珠电视台为了测试路人们的素质（那时候的电视台可真闲啊），就找了五六个大汉在马路上撬井盖，电视台是想要测试，会不会有人见义勇为站出来。在电视台录制的时间里，也就是那天晚上，有不少行人从井盖旁边走过去，但是大多数人都选择了熟视无睹，事不关己高高挂起。直到！一位姓马的热心杭州市民的出现！这是马先生第一次上电视，事实证明，侠者注定低调不了，因为实力不允许啊，马先生在后面的岁月还要频繁上电视。那年，马先生还做了一个事，就是创办了“中国黄页”，互联网科技的苗头开始发芽。</p><p>同年，深圳另一位马先生也不闲着，白天在润迅上班，晚上经营着惠多网深圳分站“ponysoft马站”。马先生不指望着“马站”赚钱，维护马站更多是出于爱好。马先生能做好马站，离不开家里人的支持，那时马先生一出差就要母亲帮他管理网站，每次临出门前都要写一张字条给母亲，告诉母亲一旦有网友打电话来说网络不通，就按照字条上的步骤排除故障，确保网络通畅。”苍天不负有心人，马站声名鹊起，马先生由此认识了当时行业的一众大佬。</p><p>互联网科技的风还没有起来，所以两位马先生当时都还是普通人。国家还在基建大开发阶段，基础设施火！ICT设备的天下！深圳一家叫“华为”的公司开始暂露头角。华为仅靠卖交换机，1995年销售额就达到15亿，第二年这家公司就开始展现狼道的一面。市场部掀起离职潮，大家要提交两份报告，一份述职报告，包含下一年规划，另一份是离职报告，公司只会批准一份。同行们，惊呆了，原来企业还可以这样。</p><p>南华为，北联想。华为在南方混的风生水起的时候，北方的联想也如日中天。联想算是当时企业界的象征，走“技工贸”路线，倪光南带领的中科院精英团队坐阵，仅在 95年销售额就是华为的4.5倍达到67亿元，卖电脑卖的不亦乐乎。后面联想开始走“贸工技”路线，短期不断创造历史新辉煌，但是长期下来还是慢慢掉队了。</p><p>1996年，浪潮来了！和联想卖电脑赚的流油一样，浪潮在服务器上也一骑绝尘。浪潮打破了国外服务器厂商的垄断，开启中国服务器新纪元，开始称王，连续十几年蝉联国产服务器第一品牌！</p><p>同年那个拍《海尔兄弟》动画片的海尔，开始 “吃休克鱼”了。对“休克鱼”，砸冰箱的张瑞敏解释是：鱼的肌体没有腐烂，比喻企业的硬件很好；而鱼处于休克状态，比喻企业的思想、观念有问题，导致企业停滞不前。这种企业一旦注入新的管理思想，有一套行之有效的管理办法，很快就能够被激活起来。后面短短几年，海尔通过资产重组、控股联营，兼并盘活亏损总额5.6亿元的18个企业，以无形资产盘活有形资产18.2亿元，总共吃了18条“休克鱼”。年底海尔开始进军彩电行业了。</p><p>这边，四川一家公司感受到市场竞争压力，不断提高技术壁垒，宣布垄断国内彩电里的彩管，彩管是电视接收器、监视器重现图像的关键器件，这家四川公司通过垄断彩电核心器件，赢取了降价的主动权，开始往电视之王奋进，这家公司叫长虹，但是十几年后还是会被劳模雷先生给降维打击。</p><p>海尔卖冰箱，长虹卖电视，当然少不了空调的战事。</p><p>1985年广东顺德的美的电器开始制造空调，美的比较扎实，稳扎稳打，在慢慢追赶当时市场大哥春兰，春兰活的比较滋润。80年代末期，100公里外的珠海诞生了一家公司叫格力电器。巧了，格力也卖空调，但大家都不把格力放在眼里，直到一位姓董的小姐出现了。</p><p>94年底，董小姐在格力电器最困难的时候，接过了经营部长一职，次年空调行业凉夏血战，董小姐誓死不降价，宁可出让市场份额也不降价，拿出1亿补贴给代理商，然后格力销售额增长17％，超过春兰，董小姐领导的格力电器从1995年-2005年，连续11年空调产销量、市场占有率全国第一。在后面的时光，能和格力一战的只有美的，格力和美的相爱相杀，互相促进中国制造品质的不断上升，有种“既生瑜，何生亮”的感觉。</p><p>还是96年，东北大学的教授刘积仁创办的东软在上海证券交易所上市，东软也成为中国第一家软件上市公司。</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>90年代末，风来了！起风了！</p><p>1998年11.11日，深圳的马先生联合同学成立了腾讯公司，并在次年2月发布了聊天软件OICQ，后面改名为“QQ”， OICQ上线几天后就是春节，所以线上显得有些冷清，马化腾只好每天从各大BBS里拉人聊天。彻底“精分”的马化腾，不一会就换个头像，有时还要扮成女孩子，看到新用户注册QQ，立马搭讪，被搭讪的网友曾调侃“当时感觉对面是个挺呆的技术工程师”。没有人意识到，这个“嘀嘀”乱叫的即时通信软件，将彻底改变中国人传统的沟通方式，重新定义社交。</p><p>另一边杭州的马先生开始新的创业故事，带着17人在湖畔花园成立了一家公司，发誓要存活102年。同年，马先生迎来了职业生涯最重要的搭档香港的蔡先生！如果把马先生比喻为刘备，那么蔡先生就是诸葛亮。后面蔡先生被大家称为财神爷。马先生做电子商务，需要钱，蔡先生名校背景，人脉广，帮马先生解决了无数次钱的问题。</p><p>说完两位马先生继续说物联网。1999年，物联网的概念在美国召开的移动计算和网络国际会议中被提出。当时基于互联网、RFID技术、EPC标准，在计算机互联网的基础上，利用射频识别技术、无线数据通信技术等，构造了一个实现全球物品信息实时共享的实物互联网“Internet of Things”。</p><p>过去在中国，物联网被称之为传感网。中科院早在1999年就启动了传感网的研究，并已取得了一些科研成果，建立了一些适用的传感网。 虽说物联网概念是在1999年才被提出，但是直到2016年，物联网才终于迎来了自己的发展元年，这17年期间，得益于技术的进步，物联网终于一步步从概念走向了成熟。17年也给硬件设备厂商、互联网云厂商提供丰富的成长时间。</p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>时间进入21世纪！</p><p>2000年，劳模雷先生出任北京金山软件总裁，雷先生是学霸，用两年时间完成大学学分，年少有成。才华得到周围所有人的认可，但是劳模真正的故事还没有开始，劳模在10年后会重新定义手机，终结山寨机，虽然手机后面遇到华为强有力的狙击，但是物联网可能让雷先生弯道超车。</p><p>众里寻他千百度，蓦然回首男神李先生回国了！李先生之前在美国留学，在美国做搜索引擎公司Infoseek做工程师，有专利，有技术，但是后面公司被迪士尼收购了，李先生不知道干嘛，李夫人让李先生回国。李先生回国做搜索引擎，海归李先生团队当时的技术国内一个能打的都没有，然后搜索引擎越做越大，并在几年后把谷歌赶出中国。李先生的百度后面会和两位马先生的公司一齐活跃在中国互联网的聚光灯下，世人谓之“BAT”。</p><p>2003年是个特殊的年份。华为差点75亿美元卖身摩托罗拉，意向书都签好了，但是最后关头摩托罗拉那边违约。庆幸没有成功，要不然今天的历史就该改写了。任总就决定自己好好做。为了抵御思科，本着敌人的敌人就是朋友的心理，华为找到了当时思科的敌人3COM公司联合成立了合资公司Huawei-3COM抵御思科。2006年华为把51％股份卖给3COM，3COM把子公司改名为H3C。华为没有想到的是，在后面的十几年里还有好多地方要和H3C一战。</p><p>这边杭州的马先生，上线了至今为止影响力最大的购物网站淘宝网，准备革了线下零售的老命。电商之王的样子开始慢慢显露出来，电商是马先生的立身之本。后面马先生依托电商向着周围不断扩散，掀起一场又一场革命，不断丰富生态链。</p><p>2004年，深圳的马先生带领腾讯公司在香港上市，腾讯后面成为港股的定海神针，腾讯打个喷嚏港股都要震几震。腾讯在物联网的故事要从9年后开始说起，2013年，腾讯云正式对外发布。依托腾讯海量用户群体，太子一出来就备受瞩目。</p><p>2006年7月4日，那个吃休克鱼的海尔发布了U－homeU－life——海尔网络家庭新标准。海尔开启“对外智慧家庭、对内互联工厂”的探索实践，让用户体验到海尔智能空调带来的“零距离”智能服务。</p><p>2007年，专注RFID技术和产品研发的远望谷在深圳上市了，RFID（无线射频识别技术）是一种非接触的自动识别技术。其基本原理是利用射频信号和空间耦合（电感或电磁耦合）或雷达反射的传输特性，实现对被识别物体的自动识别。RFID是物联网技术里面相当重要且关键的。远望谷专注RFID产业链上下游，国内无出其二，十年如一日，终于上市了。随着后面5G来临，万物互联时代到来，远望谷将带给大家更多惊喜。</p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>2008年，杭州的马先生拉来了个心理学老师来阿里巴巴做技术！王老师是心理学博士，之前在微软亚洲研究院常务副院长。王老师来阿里以后被马云委以重任执掌阿里云，从无到有。因为没有参照对象，所以就得一步步试错，好在王老师心理学学的好，内心强大，在遭受无数白眼，无数人在背后骂王老师是骗子，还是坚持了下来。阿里云的飞天操作系统后面终于成功，阿里云也成为阿里巴巴子公司中最具有理想主义的公司。</p><p>王老师当时喊来了当时微软亚洲研究院的下属林晨曦，跟他说了和马云谈的很好，要去阿里，做云计算，如果你感兴趣，可以一起来。林晨曦觉得当时的阿里，只是一家电子商务公司，和宏大的技术理想，八杆子打不着。而且大家其实有点没底，马云到底相不相信技术人，他到底想不想做?最终做决定很简单，因为相信王博士！林晨曦到阿里云做技术总监，阿里云第一行代码就是林晨曦团队写的。</p><p>2012年林晨曦离开阿里云，和同学朱珑一起联合创立“依图科技”开始了人工智能领域的探索和实践。介绍一下林晨曦，被称为学神！2002年为交大夺得ACM全球大学生程序设计竞赛总决赛首个冠军，打破亚洲零纪录。林晨曦是中国两个著名的计算机科学实验班之一上海交大ACM班培养出的第一代学生。</p><p>上海交大ACM班是俞勇带队的，愿景是要培养计算机科学家，ACM班毕业学生作品有第四范式、依图科技、森亿智能等，另外一个著名的计算机科学实验班是清华姚班，由世界著名计算机科学家姚期智创办，目的是培养国际拔尖创新计算机科学人才。清华姚班毕业学生作品有旷视科技、小马智行等。这些学神创办的企业后面在物联网感知技术识别技术方面势均力敌。</p><p>另外一边，阿里收购了大学生团队PHPWind，补齐短板。然后PHPWind全体团队都变成阿里云的第一个业务团队，由阿里巴巴CTO王坚带队，PHPWind的老大王学集被马先生委以重任，担任阿里云总经理，成为阿里云的第一任负责人。好搭档陈燎罕也成为阿里云的运营总监，带着团队四处征战，整个公司对他们都寄予厚望。</p><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>2010年4月，劳模雷先生拉来了几个兄弟联合成立了小米公司。小米是一家以手机、智能硬件和 IoT 平台为核心的互联网公司。小米手机追求极致的性价比，纯互联网销售模式统一零售价，让所有人享受到科技的美好生活，小米手机重新定义营销，饥饿营销被带到台面，从此以后，手机厂商都开始学小米卖手机，发布新手机，但是不让你轻易买到！如果你以为雷先生只是个卖手机的，那么我觉得是看不起雷先生。</p><p>雷先生的目标是星辰大海，小米手表，小米空气净化器，小米洗衣机…智联万物，可以用智能重新连接的，雷先生都会卖！性价比确实很激动人心。以致于坊间传言，雷先生家的东西除了手机外，随便买！质量杠杠的！</p><p>2010年10月，国务院发布《关于加快培育和发展战略性新兴产业的决定》，加快培育和发展以重大技术突破、重大发展需求为基础的战略性新兴产业，到2020年，战略新兴产业增加值占国内生产总值力争达到15%左右。而物联网正是战略新兴产业中新一代信息技术的重要组成部分。</p><p>2013年，男神李先生在百度建设中国首个深度学习研究院IDL。初期关注于Deep learning（深度学习）技术，并邀请这个领域中全球最顶尖高手陆续加盟。男神初衷是好的，但是结果不如意，高手们来了，但是百度都没有留住。几年间百度曾经聚集了一大批AI技术大牛——王劲、余凯、吴恩达、张潼、倪凯、楼天成、顾嘉唯等等——如今他们如今陆续离职出走，不少人选择去到了腾讯、阿里、今日头条等大公司进行下一阶段的AI投入，但绝大部分还是选择了下海创业。</p><p>2014年王学集和陈燎罕先后从阿里云离职，同年6月，他们共同创立了涂鸦智能，其中十几个人都来自PW的早期团队。涂鸦智能的所有业务都是围绕智能和云服务展开的。涂鸦智能不创造东西，而是给传统产品装上了‘智能’系统，装上‘大脑’。涂鸦科技的方向是让“中国制造”变成“中国智造”。物联网战场上涂鸦智能变成不可忽视的一股力量。</p><p>同样是2014年，深圳的马先生开始在物联网领域有动作了，推出“QQ物联智能硬件开放平台”，将QQ账号体系及关链、QQ消息通道等核心能力提供给可穿戴设备、智能家居、智能车载、传统硬件等领域合作伙伴，实现用户与设备及设备与设备之间的互联互通互动。</p><p>2015年5月，百度研究院副院长余凯离职，同年 7 月成立地平线机器人公司，虽是一个初创企业，却有一个优秀的人工智能团队，具有世界领先的深度学习和决策推理算法开发能力，将算法集成在高性能、低功耗、低成本的嵌入式人工智能处理器及软硬件平台上。地平线是少有的既能做芯片又能做算法的人工智能公司。</p><h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p>2016年3月，《国民经济和社会发展第十三个五年规划》发布，规划里面谈到要实施”互联网+”行动计划，发展物联网技术和应用，发展分享经济，促进互联网和经济社会融合发展。同年12月，《“十三五”国家信息化规划》 发布，规划里面谈到要推动物联网感知设施规划布局，发展物联网开发应用，深化物联网在城市基础设施和生产经营中的应用。</p><p>2018年3月，阿里巴巴副总裁胡晓明宣布阿里巴巴将全面进军物联网领域，IoT是阿里巴巴集团继电商、金融、物流、云计算后新的主赛道。阿里云IoT的定位是物联网基础设施的搭建者，阿里云计划在未来5年内连接100亿台设备。</p><p>2018年9月，阿里宣布合并中天微达摩院团队，成立平头哥半导体芯片公司，截止今年10月，平头哥共发布三款芯片，玄铁910”帮助企业设计制造高性能端上芯片，无剑SoC平台助力企业降低芯片设计门槛，含光800发力AI云端算力的输出。</p><p>2019年8月9日，华为正式发布操作系统鸿蒙OS。鸿蒙OS是一款“面向未来”的操作系统，一款基于微内核的面向全场景的分布式操作系统，它将适配手机、平板、电视、智能汽车、可穿戴设备等多终端设备。鸿蒙是一款性能极佳的物联网系统。</p><p>看似不同体量的公司，其实都是这场物联网狂欢中的主角；看似不相关的公司，其实都是这场物联网狂欢中的竞争对手！移动互联网产生了几家千亿市值、十几家百亿市值的公司；物联网比移动互联网市场更大，有更多想象空间。现有的玩家都不愿意失去这场狂欢的门票，都在奋力角逐。</p><p>中国物联网激荡20年，好戏才刚刚开始！</p><p>————————————————</p><p><em>原文链接：<a href="https://blog.csdn.net/weixin_41033724/article/details/102152677" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41033724/article/details/102152677</a></em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;故事还要从24年前那个夏天说起。&lt;/p&gt;
&lt;h3 id=&quot;1&quot;&gt;&lt;a href=&quot;#1&quot; class=&quot;headerlink&quot; title=&quot;1&quot;&gt;&lt;/a&gt;1&lt;/h3&gt;&lt;p&gt;1995年的夏天，美国西海岸有一个中年人出版了一本叫《未来之路》的书籍，这本书是大家了解信息高速公路全部面目乃至21世纪人类生活面貌的入门书。在这本书中，这个中年人多次提到“物物互联”的设想。但是由于当时网络技术与传感器应用水平的限制，中年人朦胧的“物联网”理念没有引起重视。对了，这个中年人后面做了十几次世界首富！&lt;/p&gt;
    
    </summary>
    
    
      <category term="行业" scheme="https://www.anjinyang.top/tags/%E8%A1%8C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>hello</title>
    <link href="https://www.anjinyang.top/2019/10/16/hello/"/>
    <id>https://www.anjinyang.top/2019/10/16/hello/</id>
    <published>2019-10-16T02:34:56.000Z</published>
    <updated>2019-10-16T03:04:09.830Z</updated>
    
    <content type="html"><![CDATA[<p>你好，这是一篇测试文章。</p> <a id="more"></a> <p><img src="/2019/10/16/hello/testPic.jpg" alt="testPic"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你好，这是一篇测试文章。&lt;/p&gt;
    
    </summary>
    
    
      <category term="test" scheme="https://www.anjinyang.top/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://www.anjinyang.top/2019/10/15/hello-world/"/>
    <id>https://www.anjinyang.top/2019/10/15/hello-world/</id>
    <published>2019-10-15T12:21:30.957Z</published>
    <updated>2019-10-16T03:05:50.407Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>. <a id="more"></a> </p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>蓝桥杯真题-密文搜索</title>
    <link href="https://www.anjinyang.top/2019/06/02/%E5%AF%86%E6%96%87%E6%90%9C%E7%B4%A2%E8%93%9D%E6%A1%A5/"/>
    <id>https://www.anjinyang.top/2019/06/02/密文搜索蓝桥/</id>
    <published>2019-06-02T01:43:01.000Z</published>
    <updated>2019-10-16T03:04:48.652Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>福尔摩斯从X星收到一份资料，全部是小写字母组成。他的助手提供了另一份资料：许多长度为8的密码列表。福尔摩斯发现，这些密码是被打乱后隐藏在先前那份资料中的。</p><p>请你编写一个程序，从第一份资料中搜索可能隐藏密码的位置。要考虑密码的所有排列 <a id="more"></a> 可能性。</p><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><p>输入第一行：一个字符串s，全部由小写字母组成，长度小于1024*1024<br>紧接着一行是一个整数n,表示以下有n行密码，1&lt;=n&lt;=1000<br>紧接着是n行字符串，都是小写字母组成，长度都为8</p><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><p>一个整数, 表示每行密码的所有排列在s中匹配次数的总和。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aaaabbbbaabbcccc</span><br><span class="line">2</span><br><span class="line">aaaabbbb</span><br><span class="line">abcabccc</span><br></pre></td></tr></table></figure><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">string</span> s1;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; maps;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s&gt;&gt;n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len=s.length();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+<span class="number">7</span>&lt;len;i++)<span class="comment">//i+8错误，应为i+7 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+<span class="number">8</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line">temp+=s[j];</span><br><span class="line">sort(temp.begin(),temp.end());</span><br><span class="line">maps[temp]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s1;</span><br><span class="line">sort(s1.begin(),s1.end());</span><br><span class="line"><span class="comment">//if(maps.count(s1))ans++;</span></span><br><span class="line"><span class="keyword">if</span>(maps.count(s1))ans+=maps[s1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h3&gt;&lt;p&gt;福尔摩斯从X星收到一份资料，全部是小写字母组成。他的助手提供了另一份资料：许多长度为8的密码列表。福尔摩斯发现，这些密码是被打乱后隐藏在先前那份资料中的。&lt;/p&gt;
&lt;p&gt;请你编写一个程序，从第一份资料中搜索可能隐藏密码的位置。要考虑密码的所有排列&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://www.anjinyang.top/tags/algorithm/"/>
    
      <category term="基础算法" scheme="https://www.anjinyang.top/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
      <category term="stl" scheme="https://www.anjinyang.top/tags/stl/"/>
    
      <category term="蓝桥" scheme="https://www.anjinyang.top/tags/%E8%93%9D%E6%A1%A5/"/>
    
  </entry>
  
  <entry>
    <title>牛客网-小a与星际探索</title>
    <link href="https://www.anjinyang.top/2019/06/02/%E5%B0%8Fa%E4%B8%8E%E6%98%9F%E9%99%85%E6%8E%A2%E7%B4%A2vector%E5%90%91%E9%87%8F/"/>
    <id>https://www.anjinyang.top/2019/06/02/小a与星际探索vector向量/</id>
    <published>2019-06-02T01:43:01.000Z</published>
    <updated>2019-10-16T03:05:32.890Z</updated>
    
    <content type="html"><![CDATA[<h1 id="小a与星际探索"><a href="#小a与星际探索" class="headerlink" title="小a与星际探索"></a>小a与星际探索</h1><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>链接：</p><p><a href="https://ac.nowcoder.com/acm/contest/317/C" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/317/C</a></p><p>来源：牛客网</p><p>小a正在玩一款星际探索游戏，小a需要驾驶着飞船从1号星球出发前往n号星球。其中每个星球有一个能量指数pi。星球i 能到达 星球j 当且仅当pi&gt;pj。同时小a的飞船还有一个耐久度t，初始时为1号点的能量指数，若小a前往星球j，那么飞船的耐久度会变为t⊕pj(即t异或pj，关于其定义请自行百度)小a想知道到达n号星球时耐久度最大为多少。注意：对于每个位置来说，从它出发可以到达的位置仅与两者的能量指数p有关，与下标无关。 <a id="more"></a> </p><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行一个整数n，表示星球数</span><br><span class="line">接下来一行有n个整数，第i个整数表示pi</span><br></pre></td></tr></table></figure><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个整数表示到达n号星球时最大的耐久度</span><br><span class="line">若不能到达n号星球或到达时的最大耐久度为0则输出−1</span><br></pre></td></tr></table></figure><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">小a有两种方法到达3号星球</span><br><span class="line">第一种：</span><br><span class="line">1→2→3，最终耐久度为457⊕456⊕23=22</span><br><span class="line">第二种：</span><br><span class="line">1→3，最终耐久度为457⊕23=478</span><br><span class="line"></span><br><span class="line">1⩽n,∀pi⩽3000</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3005</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,p[N];<span class="comment">//求异或最大（本题只能异或比自己当前异或的数小的数，不影响异或选出来的所有的数。）上三角矩阵，最大独立集（任何一个数不能被其他的数异或出来），求法高斯消元。 </span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">cin</span>&gt;&gt;p[i];</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)<span class="built_in">cout</span>&lt;&lt;(p[<span class="number">0</span>]?p[<span class="number">0</span>]:<span class="number">-1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(p[<span class="number">0</span>]&lt;=p[n<span class="number">-1</span>])<span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;sets;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p[i]&lt;p[<span class="number">0</span>]&amp;&amp;p[i]&gt;p[n<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line">sets.push_back(p[i]);<span class="comment">//因为只能到达比当前星球能量指数小的星球，初始星球能量指数为p[0]，最终要求到第n个星球（能量指数为p[n-1]），所以中间的星球能量指数一定在p[0]到p[n-1]之间。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sets.size())<span class="comment">//这里高斯消元的过程。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">14</span>,k=<span class="number">0</span>;i&gt;=<span class="number">0</span>;i--)<span class="comment">//寻找第I位为1的数，让其下标为K； </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=k;j&lt;sets.size();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(sets[j]&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">swap(sets[j],sets[k]);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sets[k]&gt;&gt;i&amp;<span class="number">1</span>)<span class="comment">//检查后面的数，如果该位上也为1，则让其变为0 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=k+<span class="number">1</span>;j&lt;sets.size();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(sets[j]&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sets[j]^=sets[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res=p[<span class="number">0</span>]^p[n<span class="number">-1</span>];<span class="comment">//答案肯定包括第一个能量和最后一个能量。</span></span><br><span class="line"><span class="keyword">if</span>(sets.size())<span class="comment">//扫一遍求答案即可。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">14</span>,k=<span class="number">0</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(sets[k]&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!(res&gt;&gt;i&amp;<span class="number">1</span>))res^=sets[k]; </span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!res)res=<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;小a与星际探索&quot;&gt;&lt;a href=&quot;#小a与星际探索&quot; class=&quot;headerlink&quot; title=&quot;小a与星际探索&quot;&gt;&lt;/a&gt;小a与星际探索&lt;/h1&gt;&lt;h3 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h3&gt;&lt;p&gt;链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/317/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/contest/317/C&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来源：牛客网&lt;/p&gt;
&lt;p&gt;小a正在玩一款星际探索游戏，小a需要驾驶着飞船从1号星球出发前往n号星球。其中每个星球有一个能量指数pi。星球i 能到达 星球j 当且仅当pi&amp;gt;pj。同时小a的飞船还有一个耐久度t，初始时为1号点的能量指数，若小a前往星球j，那么飞船的耐久度会变为t⊕pj(即t异或pj，关于其定义请自行百度)小a想知道到达n号星球时耐久度最大为多少。注意：对于每个位置来说，从它出发可以到达的位置仅与两者的能量指数p有关，与下标无关。&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://www.anjinyang.top/tags/algorithm/"/>
    
      <category term="数论" scheme="https://www.anjinyang.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="高斯消元" scheme="https://www.anjinyang.top/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"/>
    
      <category term="矩阵" scheme="https://www.anjinyang.top/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>牛客网-小a与轰炸游戏</title>
    <link href="https://www.anjinyang.top/2019/06/02/%E5%B0%8Fa%E4%B8%8E%E8%BD%B0%E7%82%B8%E6%B8%B8%E6%88%8F/"/>
    <id>https://www.anjinyang.top/2019/06/02/小a与轰炸游戏/</id>
    <published>2019-06-02T01:43:01.000Z</published>
    <updated>2019-10-16T03:05:18.506Z</updated>
    
    <content type="html"><![CDATA[<h1 id="小a与轰炸游戏"><a href="#小a与轰炸游戏" class="headerlink" title="小a与轰炸游戏"></a>小a与轰炸游戏</h1><p>链接：</p><p><a href="https://ac.nowcoder.com/acm/contest/317/E" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/317/E</a></p><p>来源：牛客网</p><p>小a正在玩一款即时战略游戏，现在他要用航空母舰对敌方阵地进行轰炸<br> 地方阵地可以看做是n×m的矩形<br> 航空母舰总共会派出q架飞机。<br> 飞机有两种，第一种飞机会轰炸以(xi,yi)为中心，对角线长为li的正菱形(也就是两条对角线分别于x轴 y轴平行的正方形)，而第二种飞机只会轰炸正菱形的上半部分(包括第xi行)<br> (具体看样例解释) <a id="more"></a><br> 现在小a想知道所有格子被轰炸次数的异或和<br> 注意：不保证被轰炸的格子一定在矩形范围内，若越界请忽略</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行三个整数n,m,q，分别表示矩阵的长/宽/询问次数</span><br><span class="line">接下来q行，每行四个整数opt,x,y,l，表示飞机类型，轰炸的坐标，以及对角线长度</span><br><span class="line">保证l为奇数！</span><br></pre></td></tr></table></figure><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个整数，表示所有格子被轰炸次数的异或和</span><br></pre></td></tr></table></figure><p>分析：二维差分，更复杂了，分四个方向需要一开始就想到。写代码难点在up、down函数的下标和计算答案时候考虑到取什么范围的数。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3005</span>,L=<span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N][N],b[N][N],c[N][N],d[N][N];<span class="comment">//用4个方向的差分避免了互相影响，如果在一个数组可能会让不同的数据之间抵消。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> l)</span><span class="comment">//up down里面的下标特比容易写错</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a[x-l/<span class="number">2</span>][y]++,b[x-l/<span class="number">2</span>][y+<span class="number">1</span>]--;</span><br><span class="line">a[x+<span class="number">1</span>][y-l/<span class="number">2</span><span class="number">-1</span>]--;b[x+<span class="number">1</span>][y+l/<span class="number">2</span>+<span class="number">2</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">c[x+<span class="number">1</span>][y-l/<span class="number">2</span>+<span class="number">1</span>]++,d[x+<span class="number">1</span>][y+l/<span class="number">2</span>]--;</span><br><span class="line">c[x+l/<span class="number">2</span>+<span class="number">1</span>][y+<span class="number">1</span>]--,d[x+l/<span class="number">2</span>+<span class="number">1</span>][y]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m,q;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,opt,x,y,l;i&lt;q;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;opt,&amp;x,&amp;y,&amp;l);</span><br><span class="line">x+=L,y+=L;<span class="comment">//偏移做法，中间为1000*1000的正方形，最后计算答案的时候计算从L+1到L+n行，L+1列到L+m列。</span></span><br><span class="line">up(x,y,l);</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="number">1</span>) down(x,y,l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=L*<span class="number">2</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;L*<span class="number">2</span>+m;j++)</span><br><span class="line">&#123;</span><br><span class="line">t+=a[i][j]+b[i][j]+c[i][j]+d[i][j];<span class="comment">//这里由差分数列求前缀和，和即为轰炸的次数。</span></span><br><span class="line"><span class="keyword">if</span>(i&gt;=L+<span class="number">1</span>&amp;&amp;i&lt;=L+n&amp;&amp;j&gt;=L+<span class="number">1</span>&amp;&amp;j&lt;=L+m)ans^=t;</span><br><span class="line">a[i+<span class="number">1</span>][j<span class="number">-1</span>]+=a[i][j];<span class="comment">//因为差分数列通过改变开头和结尾两个数达到改变整个数组的目的，所以在计算完一部分之后，为了不再重复回到上面计算，这里直接做顺延操作，避免了重复操作。</span></span><br><span class="line">b[i+<span class="number">1</span>][j+<span class="number">1</span>]+=b[i][j];</span><br><span class="line">c[i+<span class="number">1</span>][j+<span class="number">1</span>]+=c[i][j];</span><br><span class="line">d[i+<span class="number">1</span>][j<span class="number">-1</span>]+=d[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;小a与轰炸游戏&quot;&gt;&lt;a href=&quot;#小a与轰炸游戏&quot; class=&quot;headerlink&quot; title=&quot;小a与轰炸游戏&quot;&gt;&lt;/a&gt;小a与轰炸游戏&lt;/h1&gt;&lt;p&gt;链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/317/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/contest/317/E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来源：牛客网&lt;/p&gt;
&lt;p&gt;小a正在玩一款即时战略游戏，现在他要用航空母舰对敌方阵地进行轰炸&lt;br&gt; 地方阵地可以看做是n×m的矩形&lt;br&gt; 航空母舰总共会派出q架飞机。&lt;br&gt; 飞机有两种，第一种飞机会轰炸以(xi,yi)为中心，对角线长为li的正菱形(也就是两条对角线分别于x轴 y轴平行的正方形)，而第二种飞机只会轰炸正菱形的上半部分(包括第xi行)&lt;br&gt; (具体看样例解释)&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://www.anjinyang.top/tags/algorithm/"/>
    
      <category term="基础算法" scheme="https://www.anjinyang.top/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
      <category term="差分" scheme="https://www.anjinyang.top/tags/%E5%B7%AE%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>牛客网-小a与黄金街道</title>
    <link href="https://www.anjinyang.top/2019/06/02/%E5%B0%8Fa%E4%B8%8E%E9%BB%84%E9%87%91%E8%A1%97%E9%81%93%E6%AC%A7%E6%8B%89%E6%95%B0%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <id>https://www.anjinyang.top/2019/06/02/小a与黄金街道欧拉数与快速幂/</id>
    <published>2019-06-02T01:43:01.000Z</published>
    <updated>2019-10-16T03:05:26.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="小a与黄金街道"><a href="#小a与黄金街道" class="headerlink" title="小a与黄金街道"></a>小a与黄金街道</h1><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>题目连接：<a href="https://ac.nowcoder.com/acm/contest/317/D" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/317/D</a></p><p>小a和小b来到了一条布满了黄金的街道上。它们想要带几块黄金回去，然而这里的城管担心他们拿走的太多，于是要求小a和小b通过做一个游戏来决定最后得到的黄金的数量。 <a id="more"></a><br>游戏规则是这样的：<br>假设道路长度为n米(左端点为0，右端点为n)，同时给出一个数k(下面会提到k的用法)设小a初始时的黄金数量为A，小b初始时的黄金数量为B。小a从1出发走向n−1，小b从n−1出发走向1，两人的速度均为1m/s。假设某一时刻(必须为整数)小a的位置为x，小b的位置为y，若gcd(n,x)=1且gcd(n,y)=1，那么小a的黄金数量A会变为A∗k^x(kg)，小b的黄金数量B会变为B∗k^y(kg)，当小a到达n−1时游戏结束小a想知道在游戏结束时A+B的值，答案对10^9+7取模。</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一行四个整数n,k,A,B</span><br></pre></td></tr></table></figure><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出一个整数表示答案</span><br></pre></td></tr></table></figure><h3 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">保证3⩽n⩽ 10^8,1⩽A,B,k⩽ 10^13</span><br></pre></td></tr></table></figure><p>分析：这道题考察了欧拉数和快速幂。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LL X=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">quickpower</span><span class="params">(LL k,LL sum)</span><span class="comment">//快速幂模板</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(sum)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(sum&amp;<span class="number">1</span>)res=res*k%X;</span><br><span class="line">k=k*k%X;</span><br><span class="line">sum&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL n,k,a,b;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k&gt;&gt;a&gt;&gt;b;</span><br><span class="line">LL sum=n,euler=n;</span><br><span class="line"><span class="keyword">for</span>(LL p=<span class="number">2</span>;p*p&lt;=n;p++)<span class="comment">//欧拉数求法，euler=n*(1-1/a)*(1-1/b)···即，数n的欧拉数为：n乘所有的n的因子的倒数被一减去的差。欧拉数的含义：1-n所有与n互质的数的个数。一定为偶数，因为n/2与n不互质（n=2的情况特殊但也符合偶数）。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n%p==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">euler=euler/p*(p<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">while</span>(n%p==<span class="number">0</span>)n/=p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n&gt;<span class="number">1</span>)euler=euler/n*(n<span class="number">-1</span>);</span><br><span class="line">sum=sum*euler/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(a+b)*quickpower(k,sum)%X&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;小a与黄金街道&quot;&gt;&lt;a href=&quot;#小a与黄金街道&quot; class=&quot;headerlink&quot; title=&quot;小a与黄金街道&quot;&gt;&lt;/a&gt;小a与黄金街道&lt;/h1&gt;&lt;h3 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h3&gt;&lt;p&gt;题目连接：&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/317/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/contest/317/D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;小a和小b来到了一条布满了黄金的街道上。它们想要带几块黄金回去，然而这里的城管担心他们拿走的太多，于是要求小a和小b通过做一个游戏来决定最后得到的黄金的数量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://www.anjinyang.top/tags/algorithm/"/>
    
      <category term="数论" scheme="https://www.anjinyang.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="欧拉数" scheme="https://www.anjinyang.top/tags/%E6%AC%A7%E6%8B%89%E6%95%B0/"/>
    
      <category term="快速幂" scheme="https://www.anjinyang.top/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>排序专题</title>
    <link href="https://www.anjinyang.top/2019/06/02/%E6%8E%92%E5%BA%8F%E5%9F%BA%E7%A1%80/"/>
    <id>https://www.anjinyang.top/2019/06/02/排序基础/</id>
    <published>2019-06-02T01:43:01.000Z</published>
    <updated>2019-10-16T03:04:53.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序基础"><a href="#排序基础" class="headerlink" title="排序基础"></a>排序基础</h2><ol><li><p>排序目的使数据更容易处理。</p></li><li><p>排序要先找到排序键。（以什么依据排序）</p></li><li><p>数据存储用到数组、结构体或类。</p></li><li><p>排序需要考虑算法复杂度和稳定性。</p><ul><li>稳定性指数据存在两个或两个以上相等元素时，这些元素相对位置在排序前后不变。</li></ul></li></ol><p>其他考虑 <a id="more"></a> </p><ol><li>除保存数据以外是否还需要额外内存</li><li>输入数据的特征是否会对复杂度产生影响</li></ol><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>可以理解为打牌的时候，插入排序的动作。抽出一张牌，插入到已经排好序的适当位置。反复操作直到有序。</p><p>稳定排序。如果排序v&gt;arr[j]加了等于号可分析得出失去稳定性。</p><p>Q1:一个无序的数列，插入排序时第一个抽出来的数插入到哪里？</p><p>reply:输入n个数，下标从0到n-1。排序时从1到n-1，把第一个数（单独的第一个数）可以看做有序。（在归并排序中有类似想法）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> array1[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertsort</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> arr[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v=arr[i];</span><br><span class="line">        j=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;arr[j]&gt;v)<span class="comment">//升序</span></span><br><span class="line">        &#123;</span><br><span class="line">            arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        arr[j+<span class="number">1</span>]=v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;array1[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    insertsort(n,array1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">cout</span>&lt;&lt;array1[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>经典中的经典。顾名思义，冒泡排序就是让数组元素，像水中的气泡一样逐渐上浮。</p><p>这里补充一个c++交换数值的函数swap(arr[j],arr[j+1])</p><p>稳定排序。如果排序arr[j]&gt;arr[j+1]加了等于号可分析得出失去稳定性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> array1[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubblesort</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> arr[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>&amp;&amp;flag;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n-i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])<span class="comment">//升序</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp=arr[i];</span><br><span class="line">                arr[i]=arr[j];</span><br><span class="line">                arr[j]=temp;</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void bubblesort(int n,int arr[])</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int flag=1;</span></span><br><span class="line"><span class="comment">    while(flag)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        flag=0;</span></span><br><span class="line"><span class="comment">        for(int j=n-1;j&gt;0;j--)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            if(arr[j]&lt;arr[j-1])//升序排列</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                int temp=arr[j];</span></span><br><span class="line"><span class="comment">                arr[j]=arr[j-1];</span></span><br><span class="line"><span class="comment">                arr[j-1]=temp;</span></span><br><span class="line"><span class="comment">                flag=1;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;array1[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bubblesort(n,array1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">cout</span>&lt;&lt;array1[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;排序基础&quot;&gt;&lt;a href=&quot;#排序基础&quot; class=&quot;headerlink&quot; title=&quot;排序基础&quot;&gt;&lt;/a&gt;排序基础&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;排序目的使数据更容易处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;排序要先找到排序键。（以什么依据排序）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据存储用到数组、结构体或类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;排序需要考虑算法复杂度和稳定性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;稳定性指数据存在两个或两个以上相等元素时，这些元素相对位置在排序前后不变。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其他考虑&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://www.anjinyang.top/tags/algorithm/"/>
    
      <category term="基础算法" scheme="https://www.anjinyang.top/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="https://www.anjinyang.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>搜索专题</title>
    <link href="https://www.anjinyang.top/2019/06/02/%E6%90%9C%E7%B4%A2%E4%B8%93%E9%A2%98/"/>
    <id>https://www.anjinyang.top/2019/06/02/搜索专题/</id>
    <published>2019-06-02T01:43:01.000Z</published>
    <updated>2019-10-16T03:05:01.090Z</updated>
    
    <content type="html"><![CDATA[<h2 id="棋盘问题"><a href="#棋盘问题" class="headerlink" title="棋盘问题"></a>棋盘问题</h2><p> 在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。 <a id="more"></a> </p><p>Input</p><p>输入含有多组测试数据。<br>每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n<br>当为-1 -1时表示输入结束。<br>随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。 </p><p>Output</p><p>对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">#.</span><br><span class="line">.#</span><br><span class="line">4 4</span><br><span class="line">...#</span><br><span class="line">..#.</span><br><span class="line">.#..</span><br><span class="line">#...</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">int</span> mp[N][N];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">bool</span> col[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(col,<span class="literal">true</span>,<span class="keyword">sizeof</span> col);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> ro,<span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt;ro &lt;&lt; " ro    " &lt;&lt; n &lt;&lt; " n    " &lt;&lt; cnt &lt;&lt; " cnt    " &lt;&lt; k &lt;&lt; " k" &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span>(cnt == k)</span><br><span class="line">    &#123;</span><br><span class="line">        ans ++;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ro == n)<span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*for(int i = 0;i &lt; n; ++ i)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if(! col[i] || mp[ro][i] == 1)continue;</span></span><br><span class="line"><span class="comment">        else</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            //cout &lt;&lt; ro &lt;&lt; " " &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">            dfs(ro + 1,cnt);</span></span><br><span class="line"><span class="comment">            col[i] = false;</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            dfs(ro + 1, cnt + 1);</span></span><br><span class="line"><span class="comment">            col[i] = true;</span></span><br><span class="line"><span class="comment">        &#125;//c&lt;=2^31 这个递归空间很大，逐个遍历所有空间所以浪费时间，应该想办法省去不选的递归空间</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = ro;i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(! col[j] || mp[i][j] == <span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; ro &lt;&lt; " " &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">                col[j] = <span class="literal">false</span>;</span><br><span class="line">                </span><br><span class="line">                dfs(i + <span class="number">1</span>, cnt + <span class="number">1</span>);</span><br><span class="line">                col[j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">-1</span> &amp;&amp; k == <span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        getchar();</span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n; ++ j)</span><br><span class="line">            &#123;</span><br><span class="line">                c=getchar();</span><br><span class="line">                <span class="comment">//cout &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">if</span>(c == <span class="string">'#'</span>)mp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> mp[i][j] = <span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            getchar();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;棋盘问题&quot;&gt;&lt;a href=&quot;#棋盘问题&quot; class=&quot;headerlink&quot; title=&quot;棋盘问题&quot;&gt;&lt;/a&gt;棋盘问题&lt;/h2&gt;&lt;p&gt; 在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://www.anjinyang.top/tags/algorithm/"/>
    
      <category term="基础算法" scheme="https://www.anjinyang.top/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
      <category term="深度优先搜索" scheme="https://www.anjinyang.top/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
      <category term="广度优先搜索" scheme="https://www.anjinyang.top/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>博弈论专题</title>
    <link href="https://www.anjinyang.top/2019/06/02/%E5%8D%9A%E5%BC%88%E8%AE%BA%E4%B8%93%E9%A2%98/"/>
    <id>https://www.anjinyang.top/2019/06/02/博弈论专题/</id>
    <published>2019-06-02T01:43:01.000Z</published>
    <updated>2019-10-16T03:04:22.002Z</updated>
    
    <content type="html"><![CDATA[<h3 id="巴什博奕"><a href="#巴什博奕" class="headerlink" title="巴什博奕"></a>巴什博奕</h3><p>两个人，n个石子，每次可以取1-m个石子，不能拿的人失败，另一个人胜利</p><ul><li>1 &lt;= 石子数量 &lt;= m 时，先手必胜</li><li>m + 1 = 石子数量 时，先手必败</li><li>m + 2 &lt;= 石子数量 &lt;= 2 * m 时，先手可以让石子数量变为 m + 1 先手必胜</li></ul><p>推广可得 <a id="more"></a> </p><ul><li>当n = k * (m + 1) + r</li></ul><p>先手拿走r个，每次都可以让另一个人面对k * (m + 1)的棋局，直到k = 1。所以先手必胜</p><ul><li>当n = k * (m + 1)</li></ul><p>无论先手拿几个，后手每次都可以让先手面对k * (m + 1)的棋局，直到k = 1。所以先手必败</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">if</span>(n % (m + <span class="number">1</span>) == <span class="number">0</span>)<span class="built_in">cout</span> &lt;&lt; <span class="string">"second"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"first"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="斐波那契博奕"><a href="#斐波那契博奕" class="headerlink" title="斐波那契博奕"></a>斐波那契博奕</h3><p>一堆石子，先取者可以任意取，但是不能取完，以后每个人取得石子数都不能超过上个人的两倍</p><p>先手必败，当且仅当石子数为斐波那契数时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> feb[<span class="number">100</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">100</span>; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        feb[i] = feb[i - <span class="number">1</span>]+feb[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; feb[100] &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(binary_search(feb,feb + <span class="number">100</span>,n))<span class="built_in">cout</span> &lt;&lt; <span class="string">"Second win"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"First win"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="威佐夫博弈"><a href="#威佐夫博弈" class="headerlink" title="威佐夫博弈"></a>威佐夫博弈</h3><p>有两堆石子，每次可以从一堆石子中取任意多的石子，或者从两堆石子中取同样多的石子，不能取的人输</p><p>两堆石子（x , y）(x &lt; y)，先手必败，当且仅当<br>$$<br>（y - x）\times(1+\sqrt{5})\div2=x<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> t=(<span class="number">1.0</span>+<span class="built_in">sqrt</span>(<span class="number">5</span>))/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &lt; a)swap(a,b);</span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">int</span>)((b - a) * t) == a)<span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尼姆博奕"><a href="#尼姆博奕" class="headerlink" title="尼姆博奕"></a>尼姆博奕</h3><p>有n堆石子，两个人可以从任意一堆石子中拿任意多个石子（不能不拿），没法拿的失败</p><p>当n堆石子数量异或和为0时，先手必败。</p><p>当n堆石子数量异或和不为0，可以某一个数减去n-1堆石子数量异或和，先手必胜。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans,cnt,arr[N],m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; m &amp;&amp; m)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">            ans ^= arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="number">0</span>)<span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m; ++ i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t = ans ^ arr[i];<span class="comment">//求n-1堆石子的异或和，一个数字被异或和两次，相当于没有参加运算。一个数异或2次得0,0异或任何值都为它本身</span></span><br><span class="line">                <span class="keyword">if</span>(arr[i] &gt;= t)cnt ++ ;<span class="comment">//如果可以减，方案加一</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;巴什博奕&quot;&gt;&lt;a href=&quot;#巴什博奕&quot; class=&quot;headerlink&quot; title=&quot;巴什博奕&quot;&gt;&lt;/a&gt;巴什博奕&lt;/h3&gt;&lt;p&gt;两个人，n个石子，每次可以取1-m个石子，不能拿的人失败，另一个人胜利&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= 石子数量 &amp;lt;= m 时，先手必胜&lt;/li&gt;
&lt;li&gt;m + 1 = 石子数量 时，先手必败&lt;/li&gt;
&lt;li&gt;m + 2 &amp;lt;= 石子数量 &amp;lt;= 2 * m 时，先手可以让石子数量变为 m + 1 先手必胜&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;推广可得&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://www.anjinyang.top/tags/algorithm/"/>
    
      <category term="基础算法" scheme="https://www.anjinyang.top/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
      <category term="博弈论" scheme="https://www.anjinyang.top/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>日常赛-糖果传递题解</title>
    <link href="https://www.anjinyang.top/2019/06/02/%E7%B3%96%E6%9E%9C%E4%BC%A0%E9%80%92/"/>
    <id>https://www.anjinyang.top/2019/06/02/糖果传递/</id>
    <published>2019-06-02T01:43:01.000Z</published>
    <updated>2019-10-16T03:05:14.234Z</updated>
    
    <content type="html"><![CDATA[<h1 id="糖果传递题解"><a href="#糖果传递题解" class="headerlink" title="糖果传递题解"></a>糖果传递题解</h1><p>有n个小朋友坐成一圈，每人有a[i]个糖果。</p><p>每人只能给左右两人传递糖果。</p><p>每人每次传递一个糖果代价为1。</p><p>求使所有人获得均等糖果的最小代价。 <a id="more"></a> </p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入一个正整数n，表示小朋友的个数。</p><p>接下来n行，每行一个整数a[i]，表示第i个小朋友初始得到的糖果的颗数。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最小代价。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤1000000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>分析：</p><p>多个考点综合的问题，感觉像一道数学题。</p><p>对于每个人，假设他的糖果数要经过两类变化：1、从后一个人拿。2、给前一个人</p><p>最终的变化结果是变为ave。</p><p>所以有</p><ul><li>a[1]-X1+X2=ave    X2=X1-(a[1]-ave)</li><li>a[2]-X2+X3=ave        X3=X1-(a[2]+a[1]-2*ave) </li></ul><p>设c[1]=a[1]-ave</p><p>c[2]=c[1]+a[2]-ave</p><p>则有c[i]=c[i-1]+a[i]-ave</p><p>则有问题|X1|+|X2|+……+|Xn|的和最小每个都可以用X1表示为</p><p>|X1|+|X1-c[1]|+|X2-c[2]|+……+|X1-c[n-1]|   </p><p>绝对值的含义又可以表示数轴上Xi到Ci的距离</p><p>所以问题转化为在c[1]到c[n-1]中选一个点到所有点的距离的和最短</p><p>（即中位数）</p><p>注意：不应该加上abs(c[n]-c[mid])，并且ans最后应该加上mid</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N],c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">LL sum=<span class="number">0</span>;<span class="comment">//记得初始化为0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">sum+=a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ave=sum/n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">c[i]=c[i<span class="number">-1</span>]+a[i]-ave;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(c+<span class="number">1</span>,c+n);<span class="comment">//c[0]=0不能参与排序影响结果</span></span><br><span class="line"></span><br><span class="line">LL ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> pos=n&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans+=<span class="built_in">abs</span>(c[pos]-c[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ans+=<span class="built_in">abs</span>(c[pos]);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;糖果传递题解&quot;&gt;&lt;a href=&quot;#糖果传递题解&quot; class=&quot;headerlink&quot; title=&quot;糖果传递题解&quot;&gt;&lt;/a&gt;糖果传递题解&lt;/h1&gt;&lt;p&gt;有n个小朋友坐成一圈，每人有a[i]个糖果。&lt;/p&gt;
&lt;p&gt;每人只能给左右两人传递糖果。&lt;/p&gt;
&lt;p&gt;每人每次传递一个糖果代价为1。&lt;/p&gt;
&lt;p&gt;求使所有人获得均等糖果的最小代价。&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://www.anjinyang.top/tags/algorithm/"/>
    
      <category term="递推" scheme="https://www.anjinyang.top/tags/%E9%80%92%E6%8E%A8/"/>
    
  </entry>
  
  <entry>
    <title>洛谷-宇宙大总统</title>
    <link href="https://www.anjinyang.top/2019/06/02/%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8Epair%E6%B4%9B%E8%B0%B7%20%E5%AE%87%E5%AE%99%E5%A4%A7%E6%80%BB%E7%BB%9F/"/>
    <id>https://www.anjinyang.top/2019/06/02/结构体与pair洛谷 宇宙大总统/</id>
    <published>2019-06-02T01:43:01.000Z</published>
    <updated>2019-10-16T03:04:37.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="洛谷-宇宙大总统"><a href="#洛谷-宇宙大总统" class="headerlink" title="洛谷 宇宙大总统"></a>洛谷 宇宙大总统</h1><p>分析：其实就是一道字符串排序，主要学习的写法一结构体，二pair。另外需要牢记比较函数，大于号为降序，小于号为升序。这道题用来熟练stl库。 <a id="more"></a> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt; P;</span><br><span class="line">P arr[<span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(P a, P b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.second.size()==b.second.size())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a.second&gt;b.second;<span class="comment">//降序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a.second.size()&gt;b.second.size();<span class="comment">//降序</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i].first=i+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;arr[i].second;</span><br><span class="line">&#125;</span><br><span class="line">sort(arr,arr+n,cmp);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;arr[<span class="number">0</span>].first&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;arr[<span class="number">0</span>].second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;洛谷-宇宙大总统&quot;&gt;&lt;a href=&quot;#洛谷-宇宙大总统&quot; class=&quot;headerlink&quot; title=&quot;洛谷 宇宙大总统&quot;&gt;&lt;/a&gt;洛谷 宇宙大总统&lt;/h1&gt;&lt;p&gt;分析：其实就是一道字符串排序，主要学习的写法一结构体，二pair。另外需要牢记比较函数，大于号为降序，小于号为升序。这道题用来熟练stl库。&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://www.anjinyang.top/tags/algorithm/"/>
    
      <category term="基础算法" scheme="https://www.anjinyang.top/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="https://www.anjinyang.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="结构体" scheme="https://www.anjinyang.top/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    
      <category term="pair" scheme="https://www.anjinyang.top/tags/pair/"/>
    
  </entry>
  
  <entry>
    <title>背包专题</title>
    <link href="https://www.anjinyang.top/2019/06/02/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>https://www.anjinyang.top/2019/06/02/背包问题/</id>
    <published>2019-06-02T01:43:01.000Z</published>
    <updated>2019-10-16T03:04:16.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><ol><li>01背包（一个物品只能选一次，换言之一个物品只有选和不选两种状态）</li><li>完全背包（每个物品不限次数）</li><li>多重背包（每个物品选的次数不一样）</li><li>混合背包（物品多种，问最大价值）</li><li>二维费用的背包 </li><li>分组背包（物品分组，每组内物品互斥）</li><li>背包问题求方案数</li><li>背包问题方案 <a id="more"></a> </li><li>有依赖的背包问题（有限制，不随便选）</li></ol><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><p>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。</p><p>第 i 件物品的体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><p>输入格式</p><p>第一行两个整数N，V，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 N 行，每行两个整数vi,wi，用空格隔开，分别表示第 i件物品的体积和价值。</p><p>输出格式</p><p>输出一个整数，表示最大价值。</p><p>数据范围</p><p>0&lt;N,V≤1000<br>0&lt;vi,wi≤1000</p><p> 输入样例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><p> 输出样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><h4 id="朴素解法，二维动态规划"><a href="#朴素解法，二维动态规划" class="headerlink" title="朴素解法，二维动态规划"></a>朴素解法，二维动态规划</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">f[i][j] 表示只有前i个物品，总体积是j，总最大价值</span><br><span class="line"></span><br><span class="line">答案为 res = max(f[n][0 - v])</span><br><span class="line"></span><br><span class="line">f[i][j]:</span><br><span class="line">1.不选第i个物品 f[i][j] = f[i - 1][j]</span><br><span class="line">2.选第i个物品 f[i][j] = f[i - 1][j - v[i]] + w[i]</span><br><span class="line"></span><br><span class="line">f[i][j] = max(1,2)</span><br><span class="line"></span><br><span class="line">f[0][0] = 0</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"><span class="keyword">int</span> v[N],w[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++ i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++ i )</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= m; ++ j )</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= v[i])</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j] = max(f[i][j],f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= m; ++ i )res = max(res,f[n][i])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：按照这个方程递推完毕后，最终的答案并不一定是f（N）（V），而是f（N）（0..V）的最大值。如果将状态的定义中的“恰”字去掉，在转移方程中就要再加入一项f（i）（v-1），这样就可以保证f（N）（V）就是最后的答案</p><h6 id="一维优化解法-优化了空间"><a href="#一维优化解法-优化了空间" class="headerlink" title="一维优化解法(优化了空间)"></a>一维优化解法(优化了空间)</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="keyword">int</span> v[N],w[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++ i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++ i )</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = m;j &gt;= v[i]; j -- )</span><br><span class="line">            f[j] = max(f[j],f[j - v[i]] + w[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。</p><p>第 i 种物品的体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><p>输入格式</p><p>第一行两个整数N，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i种物品的体积和价值。</p><p>输出格式</p><p>输出一个整数，表示最大价值。</p><p>数据范围</p><p>0&lt;N,V≤1000<br>0&lt;vi,wi≤1000</p><p>输入样例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><p>输出样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,f[N];<span class="comment">//如果是恰好用v，则只需要初始化为负无穷</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++ i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v,w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = v;j &lt;= m; ++ j )</span><br><span class="line">            f[j] = max(f[j],f[j - v] + w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>有 N 种物品和一个容量是 V 的背包。</p><p>第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p><p> 输入格式</p><p>第一行两个整数N，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。</p><p> 输出格式</p><p>输出一个整数，表示最大价值。</p><p> 数据范围</p><p>0&lt;N,V≤100<br>0&lt;vi,wi,si≤100</p><p> 输入样例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2 3</span><br><span class="line">2 4 1</span><br><span class="line">3 4 3</span><br><span class="line">4 5 2</span><br></pre></td></tr></table></figure><p> 输出样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><ol><li>f[1] = 0 答案为f[m]</li><li>f[0] = 0,其他权威负无穷，答案为max(f[0 … v])</li></ol><p>朴素解法，时间复杂度 o（n^3）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e2</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++ i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v,w,s;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = m;j &gt;= <span class="number">0</span>;j -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= s &amp;&amp; k * v &lt;= j; ++ k )</span><br><span class="line">                f[j] = max(f[j],f[j - k * v] + k * w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背包问题&quot;&gt;&lt;a href=&quot;#背包问题&quot; class=&quot;headerlink&quot; title=&quot;背包问题&quot;&gt;&lt;/a&gt;背包问题&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;01背包（一个物品只能选一次，换言之一个物品只有选和不选两种状态）&lt;/li&gt;
&lt;li&gt;完全背包（每个物品不限次数）&lt;/li&gt;
&lt;li&gt;多重背包（每个物品选的次数不一样）&lt;/li&gt;
&lt;li&gt;混合背包（物品多种，问最大价值）&lt;/li&gt;
&lt;li&gt;二维费用的背包 &lt;/li&gt;
&lt;li&gt;分组背包（物品分组，每组内物品互斥）&lt;/li&gt;
&lt;li&gt;背包问题求方案数&lt;/li&gt;
&lt;li&gt;背包问题方案&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://www.anjinyang.top/tags/algorithm/"/>
    
      <category term="基础算法" scheme="https://www.anjinyang.top/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
      <category term="dp" scheme="https://www.anjinyang.top/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>前缀和差分专题</title>
    <link href="https://www.anjinyang.top/2019/06/02/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    <id>https://www.anjinyang.top/2019/06/02/前缀和/</id>
    <published>2019-06-02T01:43:01.000Z</published>
    <updated>2019-10-16T03:04:57.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="激光炸弹"><a href="#激光炸弹" class="headerlink" title="激光炸弹"></a>激光炸弹</h1><p>一种新型的激光炸弹，可以摧毁一个边长为 R 的正方形内的所有的目标。</p><p>现在地图上有 N 个目标，用整数Xi,Yi表示目标在地图上的位置，每个目标都有一个价值Wi。 <a id="more"></a> </p><p>激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个边长为 R 的正方形的边必须和x，y轴平行。</p><p>若目标位于爆破正方形的边上，该目标不会被摧毁。</p><p>求一颗炸弹最多能炸掉地图上总价值为多少的目标。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入正整数 N 和 R ,分别代表地图上的目标数目和正方形的边长，数据用空格隔开。</p><p>接下来N行，每行输入一组数据，每组数据包括三个整数Xi,Yi,Wi,分别代表目标的x坐标，y坐标和价值，数据用空格隔开。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N≤10000,0≤Xi,Yi≤5000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">0 0 1</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>分析：前缀和以o(1)的复杂度快速求得指定区间的和。本题为二维前缀和。一维前缀和见士兵杀敌。一维，s[i]=a[0]+a[1]+…+a[i]；二维，g [i]·[j]=左上角矩阵的和。二维通常下标从1开始，不需要处理边界。大数组定义在静态区，不会爆。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5005</span>;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,r,x,y,w;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;r;</span><br><span class="line"><span class="keyword">int</span> mx=r,my=r;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">x++,y++;</span><br><span class="line">mx=max(mx,x),my=max(my,y);</span><br><span class="line">g[x][y]+=w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mx;i++)<span class="comment">//求二维前缀和</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=my;j++)</span><br><span class="line">g[i][j]+=g[i<span class="number">-1</span>][j]+g[i][j<span class="number">-1</span>]-g[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=r;i&lt;=mx;i++)<span class="comment">//题意要求边长为r的矩阵，由二维前缀和画图可推导公式。以g[i][j]为右下角的边长为r的矩阵（不包括边界，即不包括左边界和上边界）的总价值算法为：g[i][j]-g[i-r][j]-g[i][j-r]+g[i-r][j-r]。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=r;j&lt;=my;j++)</span><br><span class="line">ans=max(ans,g[i][j]-g[i-r][j]-g[i][j-r]+g[i-r][j-r]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="IncDec序列"><a href="#IncDec序列" class="headerlink" title="IncDec序列"></a>IncDec序列</h1><p>给定一个长度为 n 的数列 a1,a2,…,an，每次可以选择一个区间 [l,r]，使下标在这个区间内的数都加一或者都减一。</p><p>求至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列可能有多少种。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入正整数n。</p><p>接下来n行，每行输入一个整数，第i+1行的整数代表ai。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>第一行输出最少操作次数。</p><p>第二行输出最终能得到多少种结果。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p> 0&lt;n≤10^5,0≤ai&lt;2147483648</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>分析：做前缀和的逆运算，即差分。b[i]=a[i]-a[i-1]，则b为a的差分；可得a[i]=b[1]+……+b[i]，故a为b的前缀和。差分的性质，也就是把序列A的区间[L,R]加d，也就是把A[l],A[l+1]….A[r]都加上d，其实就是它的差分序列B中，B[l]+d,B[r+1]−d，其他的位置统统不改变。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">ll a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//做差分的时候要考虑i=1的时候 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">b[i]=a[i]-a[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for(int i=n;i&gt;1;i--)a[i]-=a[i-1];</span></span><br><span class="line"></span><br><span class="line">ll pos=<span class="number">0</span>,neg=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(b[i]&gt;<span class="number">0</span>)pos+=b[i];</span><br><span class="line"><span class="keyword">else</span> neg-=b[i];<span class="comment">//因为是负数，要想neg是正数需要用减号。 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;min(pos,neg)+<span class="built_in">abs</span>(pos-neg)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">abs</span>(pos-neg)+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*//稍微精简的写法</span></span><br><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">using namespace std;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">typedef long long ll;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">const int N=1e5+5;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">ll a[N];</span></span><br><span class="line"><span class="comment">int main()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">int n;</span></span><br><span class="line"><span class="comment">cin&gt;&gt;n;</span></span><br><span class="line"><span class="comment">for(int i=1;i&lt;=n;i++)//做差分的时候要考虑i=1的时候 </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cin&gt;&gt;a[i];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">for(int i=n;i&gt;1;i--)a[i]-=a[i-1];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">ll pos=0,neg=0;</span></span><br><span class="line"><span class="comment">for(int i=2;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">if(b[i]&gt;0)pos+=a[i];</span></span><br><span class="line"><span class="comment">else neg-=a[i];//因为是负数，要想neg是正数需要用减号。 </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">cout&lt;&lt;min(pos,neg)+abs(pos-neg)&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">cout&lt;&lt;abs(pos-neg)+1&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">return 0;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br></pre></td></tr></table></figure><h1 id="最高的牛"><a href="#最高的牛" class="headerlink" title="最高的牛"></a>最高的牛</h1><p>有 N 头牛站成一行，被编队为1、2、3…N，每头牛的身高都为整数。</p><p>当且仅当两头牛中间的牛身高都比它们矮时，两头牛方可看到对方。</p><p>现在，我们只知道其中最高的牛是第 P 头，它的身高是 H ，剩余牛的身高未知。</p><p>但是，我们还知道这群牛之中存在着 M 对关系，每对关系都指明了某两头牛 A 和 B 可以相互看见。</p><p>求每头牛的身高的最大可能值是多少。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入整数 N,P,H,M，数据用空格隔开。</p><p>接下来M行，每行输出两个整数 A 和 B ，代表牛 A 和牛 B 可以相互看见，数据用空格隔开。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>一共输出 N 行数据，每行输出一个整数。</p><p>第 i 行输出的整数代表第 i 头牛可能的最大身高。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤10000,1≤H≤1000000,1≤A,B≤10000,0≤M≤10000</p><p>分析：典型差分问题，问题的最后还结合了差分向前缀和的转化。问题关键点在于如何转化为差分模型，该题提供的关系不可能交叉，所以关系就可以看做差分要操作的区间，最高的牛的高度表明所有的高度都小于等于H，即差分数列的首项为H。在接受关系的过程中，存在判重问题，即同一对关系出现多次无用，再次出现时不可以再对该区间做相同操作（因为要求最高，出现一次，区间内所有高度减一，若再次出现，正确答案不为减二。）</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判重部分涉及：1.set&lt;pair&lt;int,int&gt;&gt;existed;2.map&lt;pair&lt;int,int&gt;,bool&gt;existed;(前者略快？map a=b也可以？)3.unordered_set(希)set&lt;int&gt;existed;4.boolexisted[10010],if(!existed[a])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> height[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,p,h,m;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;p&gt;&gt;h&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">height[<span class="number">1</span>]=h;<span class="comment">//把height看做差分数列</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; existed;<span class="comment">//这部分实现关系判重接受和区间操作</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,a,b;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="comment">//自己写落了判ab大小</span></span><br><span class="line"><span class="keyword">if</span>(a&gt;b)swap(a,b); </span><br><span class="line"><span class="keyword">if</span>(!existed.count(&#123;a,b&#125;))</span><br><span class="line">&#123;</span><br><span class="line">existed.insert(&#123;a,b&#125;);</span><br><span class="line">height[a+<span class="number">1</span>]--,height[b]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//差分转化为前缀和</span></span><br><span class="line">&#123;</span><br><span class="line">height[i]+=height[i<span class="number">-1</span>];</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;height[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;激光炸弹&quot;&gt;&lt;a href=&quot;#激光炸弹&quot; class=&quot;headerlink&quot; title=&quot;激光炸弹&quot;&gt;&lt;/a&gt;激光炸弹&lt;/h1&gt;&lt;p&gt;一种新型的激光炸弹，可以摧毁一个边长为 R 的正方形内的所有的目标。&lt;/p&gt;
&lt;p&gt;现在地图上有 N 个目标，用整数Xi,Yi表示目标在地图上的位置，每个目标都有一个价值Wi。&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://www.anjinyang.top/tags/algorithm/"/>
    
      <category term="基础算法" scheme="https://www.anjinyang.top/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
      <category term="差分" scheme="https://www.anjinyang.top/tags/%E5%B7%AE%E5%88%86/"/>
    
      <category term="前缀和" scheme="https://www.anjinyang.top/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>最短路径专题</title>
    <link href="https://www.anjinyang.top/2019/06/02/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84floyd%E3%80%81dijkstra%E3%80%81dijkstra+%20heap%E3%80%81bellman-flod%E3%80%81spfa/"/>
    <id>https://www.anjinyang.top/2019/06/02/最短路径floyd、dijkstra、dijkstra+ heap、bellman-flod、spfa/</id>
    <published>2019-06-02T01:43:01.000Z</published>
    <updated>2019-10-16T03:05:38.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="畅通工程续"><a href="#畅通工程续" class="headerlink" title="畅通工程续"></a>畅通工程续</h1><p>Problem Description</p><p>某省自从实行了很多年的畅通工程计划后，终于修建了很多路。不过路多了也不好，每次要从一个城镇到另一个城镇时，都有许多种道路方案可以选择，而某些方案要比另一些方案行走的距离要短很多。这让行人很困扰。</p><p>现在，已知起点和终点，请你计算出要从起点到终点，最短需要行走多少距离。 <a id="more"></a> </p><p>Input</p><p>本题目包含多组数据，请处理到文件结束。<br>每组数据第一行包含两个正整数N和M(0&lt;N&lt;200,0&lt;M&lt;1000)，分别代表现有城镇的数目和已修建的道路的数目。城镇分别以0～N-1编号。<br>接下来是M行道路信息。每一行有三个整数A,B,X(0&lt;=A,B&lt;N,A!=B,0&lt;X&lt;10000),表示城镇A和城镇B之间有一条长度为X的双向道路。<br>再接下一行有两个整数S,T(0&lt;=S,T&lt;N)，分别代表起点和终点。</p><p>Output</p><p>对于每组数据，请在一行里输出最短需要行走的距离。如果不存在从S到T的路线，就输出-1.</p><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">0 1 1</span><br><span class="line">0 2 3</span><br><span class="line">1 2 1</span><br><span class="line">0 2</span><br><span class="line">3 1</span><br><span class="line">0 1 1</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><h3 id="floyd-暴力算法，核心代码三个for"><a href="#floyd-暴力算法，核心代码三个for" class="headerlink" title="floyd 暴力算法，核心代码三个for"></a>floyd 暴力算法，核心代码三个for</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">205</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m,st,ed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">            arr[i][j]=(i==j?<span class="number">0</span>:inf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span><span class="comment">//时间复杂度o（n^3） 数据量小于1000时可用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;++k)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">                arr[i][j]=min(arr[i][j],arr[i][k]+arr[k][j]);<span class="comment">//直接从i到j还是i到中转点k后到j近取最小更新最短</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        init();<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">            <span class="keyword">if</span>(arr[a][b]&gt;c)arr[a][b]=arr[b][a]=c;<span class="comment">//因为是双向，所以尽量取最小</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        floyd();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;st&gt;&gt;ed;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;(arr[st][ed]==inf?<span class="number">-1</span>:arr[st][ed])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dijsktra算法"><a href="#dijsktra算法" class="headerlink" title="dijsktra算法"></a>dijsktra算法</h3><p>用于无负边权的 单元 最短路径问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">205</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[N][N];</span><br><span class="line"><span class="keyword">int</span> dis[N];<span class="comment">//存储某个点到各个点的最短路径</span></span><br><span class="line"><span class="keyword">bool</span> vis[N];<span class="comment">//不能成环，所以判断某个点是否走过</span></span><br><span class="line"><span class="keyword">int</span> n,m,st,ed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">            arr[i][j]=(i==j?<span class="number">0</span>:inf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span><span class="comment">//每次循环找最短边，然后更新某个点通过最短边到每个点的最短路径，每更新一次标记用过的边防止形成环</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;++i)<span class="comment">//某个点到其他点的最短路肯定不是环，所以n个点最多有n-1条边，要找的最短路径可能走前面的最短路径，所以最多循环n-1次一定可以找到</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> minv=inf;<span class="comment">//循环每次为了找到某个点到其他点的最短边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">            <span class="keyword">if</span>(dis[j]&lt;minv&amp;&amp;!vis[j])minv=dis[j],k=j;<span class="comment">//第一次这里忘了加vis错误，因为不能走走过的点</span></span><br><span class="line">        vis[k]=<span class="literal">true</span>;<span class="comment">//遍历过后找到了一个最短的边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;n;++v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[k][v]&lt;inf)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v]=min(dis[v],dis[k]+arr[k][v]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">            <span class="keyword">if</span>(arr[a][b]&gt;c)arr[a][b]=arr[b][a]=c;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;st&gt;&gt;ed;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)dis[i]=arr[st][i];<span class="comment">//初始化起点</span></span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);<span class="comment">//初始化用过的点</span></span><br><span class="line">        vis[st]=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        dijkstra();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;(dis[ed]==inf?<span class="number">-1</span>:dis[ed])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dijkstra-heap算法"><a href="#dijkstra-heap算法" class="headerlink" title="dijkstra+ heap算法"></a>dijkstra+ heap算法</h3><p>时间复杂度o((m+n)logn)级别小于n^2。利用优先队列自动排序，寻找最短边。这里有两种写法，一种用二维数组存储，另一种用邻接表存储。邻接表适用于边特别多的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">205</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[N][N];</span><br><span class="line"><span class="keyword">int</span> dis[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> n,m,st,ed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,inf,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">            arr[i][j]=(i==j?<span class="number">0</span>:inf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dis[st]=<span class="number">0</span>;<span class="comment">//忘记了，wa，从st开始，dis[st]=0，否则在例如第一次循环的过程中，到其他点距离为0x3f3f3f3f+某个值不越界，但是很大，第一次相当于答案加了0x3f3f3f3f</span></span><br><span class="line">    priority_queue&lt;PII,<span class="built_in">vector</span>&lt;PII&gt;,greater&lt;PII&gt; &gt; q;</span><br><span class="line">    q.push(&#123;<span class="number">0</span>,st&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        PII now=q.top();q.pop();<span class="comment">//greater小顶堆自动排序队首为最小，less队首最大大顶堆。用这个来找最短边。</span></span><br><span class="line">        <span class="keyword">int</span> vi=now.second;<span class="comment">//最短边的另一端端点</span></span><br><span class="line">        <span class="keyword">if</span>(vis[vi])<span class="keyword">continue</span>;</span><br><span class="line">        vis[vi]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i]&amp;&amp;dis[i]&gt;dis[vi]+arr[vi][i])<span class="comment">//比较通过最短边是否为最短路径，更新到每个点的最短路径</span></span><br><span class="line">            &#123;</span><br><span class="line">                dis[i]=dis[vi]+arr[vi][i];</span><br><span class="line">                q.push(&#123;dis[i],i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        init();<span class="comment">//初始化应该在输入之前，否则数据没输入。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)<span class="comment">//这里不要错，m个店</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">            arr[a][b]=arr[b][a]=min(arr[a][b],c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;st&gt;&gt;ed;</span><br><span class="line"></span><br><span class="line">        dijkstra();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;(dis[ed]==inf?<span class="number">-1</span>:dis[ed])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表写法。存在大量边的情况下适合用邻接表</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUSH(x,y,z) G[x].push_back(&#123;y,z&#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">205</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,st,ed;</span><br><span class="line"><span class="built_in">vector</span>&lt;P&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,inf,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)G[i].clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dis[st]=<span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;P,<span class="built_in">vector</span>&lt;P&gt;,greater&lt;P&gt; &gt; q;</span><br><span class="line">    q.push(&#123;<span class="number">0</span>,st&#125;);</span><br><span class="line">    <span class="keyword">while</span>(q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        P now=q.top();</span><br><span class="line">        q.pop();<span class="comment">//选最短边，找到最短边的另一个端点</span></span><br><span class="line">        <span class="keyword">int</span> u=now.second;</span><br><span class="line">        <span class="keyword">if</span>(vis[u])<span class="keyword">continue</span>;</span><br><span class="line">        vis[u]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v=G[u][i].first;</span><br><span class="line">            <span class="keyword">int</span> cost=G[u][i].second;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v]&amp;&amp;dis[v]&gt;dis[u]+cost)<span class="comment">//遍历更新，通过最短边到点G[u][i].first的最短距离。检测vis[v]是否走过，因为要更新通过u到各个点，防止成环。</span></span><br><span class="line">            &#123;</span><br><span class="line">                dis[v]=dis[u]+cost;</span><br><span class="line">                q.push(&#123;dis[v],v&#125;);<span class="comment">//仅c++11以上版本编译器支持。建议写成make_pair(int,int)，make_pair作用是把参数变成pair类型，兼容所有版本，写法：q.push(make_pair&lt;int,int&gt;);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">            PUSH(a,b,c);<span class="comment">//不用判断G[a][b].second&gt;c因为，首先第一次输入用不上，其次如果出现重复数据，在更新的时候不影响更新他的最小值。</span></span><br><span class="line">            PUSH(b,a,c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;st&gt;&gt;ed;</span><br><span class="line"></span><br><span class="line">        dijkstra();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*for(int i=0;i&lt;m;++i)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            for(int j=0;j&lt;G[i].size();++j)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                cout&lt;&lt;G[i][j].first&lt;&lt;" "&lt;&lt;G[i][j].second&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;(dis[ed]==inf?<span class="number">-1</span>:dis[ed])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bellman-flod算法"><a href="#bellman-flod算法" class="headerlink" title="bellman-flod算法"></a>bellman-flod算法</h3><p>dijkstra无法解决负权问题，此算法可以，核心代码4行，循环n - 1次。</p><p>如果存在负边权，则无最短路径。</p><p>如何保证不成环，因为总共对每条边最多做n - 1次松弛，每次松弛只有两种可能情况（1）利用未用过的较短的边松弛（2）利用负边松弛，且只要用负边权，下次还会用用过的负边权。所以松弛n - 1次，最多利用n - 1条边，总共n个点所以不会成环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,st,ed;</span><br><span class="line"><span class="keyword">int</span> pro[N],dis[N],u[N],v[N],w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bellman_Ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> k = <span class="number">0</span>;k &lt; n - <span class="number">1</span>; ++ k )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++ i )pro[i] = dis[i];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m; ++ i )</span><br><span class="line">        &#123;</span><br><span class="line">            dis[v[i]] = min(dis[v[i]],dis[u[i]] + w[i]);</span><br><span class="line">            dis[u[i]] = min(dis[u[i]],dis[v[i]] + w[i]);<span class="comment">//无向图需要反向更新一次</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> check = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++ i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pro[i] != dis[i])</span><br><span class="line">            &#123;</span><br><span class="line">                check = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(check)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> check = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m; ++ i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[v[i]] &gt; dis[u[i]] + w[i])</span><br><span class="line">        &#123;</span><br><span class="line">            check = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(check)<span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m; ++ i )<span class="built_in">cin</span> &gt;&gt; u[i] &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">        <span class="built_in">memset</span>(dis,INF,<span class="keyword">sizeof</span> dis);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; st &gt;&gt; ed;</span><br><span class="line"></span><br><span class="line">        dis[st] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Bellman_Ford();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ( dis[ed] == INF ? <span class="number">-1</span> : dis[ed]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bellman-flod-算法-队列优化-（spfa算法）"><a href="#Bellman-flod-算法-队列优化-（spfa算法）" class="headerlink" title="Bellman-flod 算法 + 队列优化 （spfa算法）"></a>Bellman-flod 算法 + 队列优化 （spfa算法）</h3><p>在Bellman-flod 算法中可以发现，很多松弛是无法进行的，只有当某一条边松弛之后，他的邻边才有可能松弛。</p><p>每次成功松弛的点入队，每次循环用已经松弛过的边松弛其他的边。</p><p>判断有无负环：如果某个点进入队列的次数超过一定次数则存在负环（在一次循环中可能会更新多次，但只入队一次，更新次数不能决定是否成环，因为一条边可以同时由许多其他边更新，一旦其他边更新，对于当前要检测是否成环的边的更新次数会超过 n - 1，入队或者出队次数才能代表该边的松弛情况，当它入队超过n - 1时，表明成环）。也可以利用Bellman-flod中检测负边权的方法。</p><p>期望的时间复杂度O(kE)， 其中k为所有顶点进队的平均次数，可以证明k一般小于等于2。</p><p>SPFA 在形式上和宽度优先搜索(bfs)非常类似，不同的是宽度优先搜索中一个点出了队列就不可能重新进入队列，但是SPFA中一个点可能在出队列之后再次被放入队列，也就是一个点改进过其它的点之后，过了一段时间可能本身被改进，于是再次用来改进其它的点，这样反复迭代下去。</p><p>SPFA算法有两个优化算法 SLF 和 LLL。</p><ul><li><p>SLF：Small Label First 策略，设要加入的节点是j，队首元素为i，若dist(j)&lt;dist(i)，则将j插入队首，否则插入队尾。</p></li><li><p>LLL：Large Label Last 策略，设队首元素为i，队列中所有dist值的平均值为x，若dist(i)&gt;x则将i插入到队尾，查找下一元素，直到找到某一i使得dist(i)&lt;=x，则将i出对进行松弛操作。</p></li><li><p>引用网上资料，SLF 可使速度提高 15 ~ 20%；SLF + LLL 可提高约 50%。 在实际的应用中SPFA的算法时间效率不是很稳定，为了避免最坏情况的出现，通常使用效率更加稳定的Dijkstra算法。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUSH(x,y,z) G[x].push(make_pair(y,z))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">int</span> n,m,st,ed;</span><br><span class="line"><span class="keyword">int</span> dis[N],arr[N][N],check[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="built_in">memset</span>(dis,INF,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="built_in">memset</span>(check,<span class="number">0</span>,<span class="keyword">sizeof</span> check);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++ i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; n; ++ j )</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i][j] = arr[j][i] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    vis[st] = <span class="literal">true</span>;</span><br><span class="line">    dis[st] = <span class="number">0</span>;</span><br><span class="line">    q.push(st);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[now] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++ i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[i] &gt; dis[now] + arr[now][i])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[i] = dis[now] + arr[now][i];</span><br><span class="line">                <span class="keyword">if</span>(!vis[i])<span class="comment">//把松弛过但不在队列中的边推进去，进而松弛其他边</span></span><br><span class="line">                &#123;</span><br><span class="line">                    check[i] ++;</span><br><span class="line">                    <span class="keyword">if</span>(check[i] &gt; n - <span class="number">1</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">                        dis[ed] = INF;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    vis[i] = <span class="literal">true</span>;</span><br><span class="line">                    q.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m; ++ i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            arr[a][b] = arr[b][a] = min(arr[a][b],c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; st &gt;&gt; ed;</span><br><span class="line">        spfa();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (dis[ed] == INF ? <span class="number">-1</span> : dis[ed]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接表写法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUSH(x,y,z) G[x].push_back(make_pair(y,z))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,st,ed,dis[N],check[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;P&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,INF,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="built_in">memset</span>(check,<span class="number">0</span>,<span class="keyword">sizeof</span> check);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N; ++ i )G[i].clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(st);</span><br><span class="line">    dis[st] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[now] = <span class="literal">false</span>;<span class="comment">//这里不能丢，如果vis[now]更新了，需要再次放入队列。</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G[now].size(); ++ i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[now][i].first;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &gt; dis[now] + G[now][i].second)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[now] + G[now][i].second;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m; ++ i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            PUSH(a,b,c);</span><br><span class="line">            PUSH(b,a,c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; st &gt;&gt; ed;</span><br><span class="line">        spfa();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (dis[ed] == INF ? <span class="number">-1</span> : dis[ed]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前向星和链式前向星"><a href="#前向星和链式前向星" class="headerlink" title="前向星和链式前向星"></a>前向星和链式前向星</h3><h5 id="前向星"><a href="#前向星" class="headerlink" title="前向星"></a>前向星</h5><p>是一种特殊的边集数组,我们把边集数组中的每一条边按照起点从小到大排序,如果起点相同就按照终点从小到大排序,</p><p>并记录下以某个点为起点的所有边在数组中的起始位置和存储长度,那么前向星就构造好了.</p><p>用len[i]来记录所有以i为起点的边在数组中的存储长度.</p><p>用head[i]记录以i为边集在数组中的第一个存储位置.</p><p><u>最终可以达到快速访问指定起点的边集。</u>缺点需要排序，快排nlogn.</p><h5 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h5><p>事实上根本不需要排序，我们的目的是在一堆数组中直接访问指定起点的边集，我们可以牺牲一些空间保存同一类集合的下标即可，对于每一条边需要保存其起点、终点、长度等。（如果是开太多数组，牺牲太多，又和邻接矩阵没差，小声bb）</p><p>对比：链式前向星和领接表的遍历速度都不如邻接矩阵，但存储的边的数量都比邻接矩阵要多，极端情况下邻接表可能会卡vector。</p><p>存边</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> head[N];<span class="comment">//一般初始化为-1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to,w;</span><br><span class="line">&#125;edge[N];</span><br></pre></td></tr></table></figure><p>写入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].next = head[u];<span class="comment">//指向上一条同起点的边</span></span><br><span class="line">    head[u] = cnt ++;<span class="comment">//更新head[u]为当前边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>edge[i].to</code>表示第i条边的终点,<code>edge[i].next</code>表示与第i条边同起点的下一条边的存储位置,<code>edge[i].w</code>为边权值.</p><p>另外还有一个数组<code>head[]</code>,它是用来表示以i为起点的第一条边存储的位置,实际上你会发现这里的第一条边存储的位置其实</p><p>在以i为起点的所有边的最后输入的那个编号.</p><p>整数快读模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">'-'</span>)f = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">        res = res * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> f * res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链式前向星 模板题 洛谷P4479</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to,w;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,st,ed,cnt;</span><br><span class="line"><span class="keyword">int</span> head[N],dis[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="built_in">memset</span>(dis,INF,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">'-'</span>)f = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(ch &lt;= <span class="string">'9'</span> &amp;&amp; ch &gt;= <span class="string">'0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res = res * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch =getchar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f * res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;P,<span class="built_in">vector</span>&lt;P&gt;,greater&lt;P&gt; &gt; q;</span><br><span class="line">    dis[st] = <span class="number">0</span>;</span><br><span class="line">    q.push(make_pair(<span class="number">0</span>,st));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        P now = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> u = now.second;</span><br><span class="line">        <span class="keyword">if</span>(vis[u])<span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = head[u]; ~ i;i = edge[i].next)</span><br><span class="line">        &#123;<span class="comment">//因为head初始化为-1，当i = -1 时结束，因为-1存储形式为111……111 按位去反后为0，所以可以写作 ~ i</span></span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v] &amp;&amp; dis[v] &gt; dis[u] + edge[i].w)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + edge[i].w;</span><br><span class="line">                q.push(make_pair(dis[v],v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    n = rd();</span><br><span class="line">    m = rd();</span><br><span class="line">    st = rd();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m; ++ i )&#123;</span><br><span class="line">        a = rd();</span><br><span class="line">        b = rd();</span><br><span class="line">        c = rd();</span><br><span class="line">        add(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dijkstra();</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++ i )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,dis[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;畅通工程续&quot;&gt;&lt;a href=&quot;#畅通工程续&quot; class=&quot;headerlink&quot; title=&quot;畅通工程续&quot;&gt;&lt;/a&gt;畅通工程续&lt;/h1&gt;&lt;p&gt;Problem Description&lt;/p&gt;
&lt;p&gt;某省自从实行了很多年的畅通工程计划后，终于修建了很多路。不过路多了也不好，每次要从一个城镇到另一个城镇时，都有许多种道路方案可以选择，而某些方案要比另一些方案行走的距离要短很多。这让行人很困扰。&lt;/p&gt;
&lt;p&gt;现在，已知起点和终点，请你计算出要从起点到终点，最短需要行走多少距离。&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://www.anjinyang.top/tags/algorithm/"/>
    
      <category term="最短路" scheme="https://www.anjinyang.top/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="图论" scheme="https://www.anjinyang.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>递归与递推专题</title>
    <link href="https://www.anjinyang.top/2019/06/02/%E9%80%92%E5%BD%92%E4%B8%93%E9%A1%B9/"/>
    <id>https://www.anjinyang.top/2019/06/02/递归专项/</id>
    <published>2019-06-02T01:43:01.000Z</published>
    <updated>2019-10-16T03:04:32.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="递归实现指数型枚举"><a href="#递归实现指数型枚举" class="headerlink" title="递归实现指数型枚举"></a>递归实现指数型枚举</h2><p>从 1~n 这 n 个整数中随机选取任意多个，输出所有可能的选择方案。 <a id="more"></a> </p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入一个整数n。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>每行输出一种方案。</p><p>同一行内的数必须升序排列，相邻两个数用恰好1个空格隔开。</p><p>对于没有选任何数的方案，输出空行。</p><p>本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">if</span>(state&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(u+<span class="number">1</span>,state);</span><br><span class="line">    dfs(u+<span class="number">1</span>,state|<span class="number">1</span>&lt;&lt;u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归实现组合型枚举"><a href="#递归实现组合型枚举" class="headerlink" title="递归实现组合型枚举"></a>递归实现组合型枚举</h2><p>从 1~n 这 n 个整数中随机选出 m 个，输出所有可能的选择方案。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>两个整数n,m 在同一行用空格隔开。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>按照从小到大的顺序输出所有方案，每行1个。</p><p>首先，同一行内的数升序排列，相邻两个数用一个空格隔开。</p><p>其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如1 3 5 7排在1 3 6 8前面）。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> sum,<span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum+n-u&lt;m)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sum==m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">if</span>(state&gt;&gt;i&amp;<span class="number">1</span>)</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if(u==n)return; 第一个if会直接判断出去所以不需要写这句话</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    dfs(u+<span class="number">1</span>,sum+<span class="number">1</span>,state|<span class="number">1</span>&lt;&lt;u);</span><br><span class="line">    dfs(u+<span class="number">1</span>,sum,state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归实现排列型枚举"><a href="#递归实现排列型枚举" class="headerlink" title="递归实现排列型枚举"></a>递归实现排列型枚举</h2><p>把 1~n 这 n 个整数排成一行后随机打乱顺序，输出所有可能的次序。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>一个整数n。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>按照从小到大的顺序输出所有方案，每行1个。</p><p>首先，同一行相邻两个数用一个空格隔开。</p><p>其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//n个坑，枚举哪个数放到第一个坑，然后枚举下一个坑，枚举没有放过的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;path;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:path)<span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(state&gt;&gt;i&amp;<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            path.push_back(i+<span class="number">1</span>);</span><br><span class="line">            dfs(u+<span class="number">1</span>,state|<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            path.pop_back();<span class="comment">//枚举完当前情况后，恢复现场。保证同一次枚举的时候，对于所有的分支在进入之前他的所有状态都是一样的。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="费解的开关"><a href="#费解的开关" class="headerlink" title="费解的开关"></a>费解的开关</h2><p>你玩过“拉灯”游戏吗？25盏灯排成一个5x5的方形。每一个灯都有一个开关，游戏者可以改变它的状态。每一步，游戏者可以改变某一个灯的状态。游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。</p><p>我们用数字“1”表示一盏开着的灯，用数字“0”表示关着的灯。下面这种状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10111</span><br><span class="line">01101</span><br><span class="line">10111</span><br><span class="line">10000</span><br><span class="line">11011</span><br></pre></td></tr></table></figure><p>在改变了最左上角的灯的状态后将变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">01111</span><br><span class="line">11101</span><br><span class="line">10111</span><br><span class="line">10000</span><br><span class="line">11011</span><br></pre></td></tr></table></figure><p>再改变它正中间的灯后状态将变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">01111</span><br><span class="line">11001</span><br><span class="line">11001</span><br><span class="line">10100</span><br><span class="line">11011</span><br></pre></td></tr></table></figure><p>给定一些游戏的初始状态，编写程序判断游戏者是否可能在6步以内使所有的灯都变亮。</p><h4 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入正整数n，代表数据中共有n个待解决的游戏初始状态。</p><p>以下若干行数据分为n组，每组数据有5行，每行5个字符。每组数据描述了一个游戏的初始状态。各组数据间用一个空行分隔。</p><h4 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h4><p>一共输出n行数据，每行有一个小于等于6的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。</p><p>对于某一个游戏初始状态，若6步以内无法使所有灯变亮，则输出“-1”。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;//memcpy在这儿</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> g[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;<span class="comment">//向量技巧，以此表示中心，向上，向右，向下，向左</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turn</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//按下操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)<span class="comment">//一开始写错了写了两重循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=x+dx[i],b=y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(a&gt;=<span class="number">0</span>&amp;&amp;a&lt;<span class="number">5</span>&amp;&amp;b&gt;=<span class="number">0</span>&amp;&amp;b&lt;<span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            g[a][b]^=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">1</span>&lt;&lt;<span class="number">5</span>;k++)<span class="comment">//枚举第一行的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> backup[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(backup,g,<span class="keyword">sizeof</span> g);<span class="comment">//记录原始状态</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)<span class="comment">//操作第一行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k&gt;&gt;j&amp;<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">                turn(<span class="number">0</span>,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)<span class="comment">//操作后面几行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(g[i][j]==<span class="string">'0'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    turn(i+<span class="number">1</span>,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> is_successful=<span class="literal">true</span>;<span class="comment">//根据最后一行有无0判断是否成功</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[<span class="number">4</span>][i]==<span class="string">'0'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                is_successful=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(is_successful)</span><br><span class="line">        &#123;</span><br><span class="line">            ans=min(res,ans);<span class="comment">//记录最小值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(g,backup,<span class="keyword">sizeof</span> g);<span class="comment">//返回初始状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ans&gt;<span class="number">6</span>) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//return 的位置写错了</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)<span class="built_in">cin</span>&gt;&gt;g[i];<span class="comment">//char数组不需要写到二维</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;work()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="奇怪的汉诺塔"><a href="#奇怪的汉诺塔" class="headerlink" title="奇怪的汉诺塔"></a>奇怪的汉诺塔</h2><p>汉诺塔问题，条件如下：</p><p>1、这里有A、B、C和D四座塔。</p><p>2、这里有n个圆盘，n的数量是恒定的。</p><p>3、每个圆盘的尺寸都不相同。</p><p>4、所有的圆盘在开始时都堆叠在塔A上，且圆盘尺寸从塔顶到塔底逐渐增大。</p><p>5、我们需要将所有的圆盘都从塔A转移到塔D上。</p><p>6、每次可以移动一个圆盘，当塔为空塔或者塔顶圆盘尺寸大于被移动圆盘时，可将圆盘移至这座塔上。</p><p>请你求出将所有圆盘从塔A移动到塔D，所需的最小移动次数是多少。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">15</span>],f[<span class="number">15</span>];</span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;<span class="number">13</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        d[i]=<span class="number">2</span>*d[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> f);<span class="comment">//使f中最大，后面用来min</span></span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">13</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i]=min(f[i],f[j]*<span class="number">2</span>+d[i-j]);<span class="comment">//后面的算法借鉴基本汉诺塔的算法，因为共四个柱子，最开始把一定数量的圆盘移动到一个柱子上，此时还剩两个柱子，可以完成基础汉诺塔的操作。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">12</span>;i++)<span class="built_in">cout</span>&lt;&lt;f[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="约数之和"><a href="#约数之和" class="headerlink" title="约数之和"></a>约数之和</h2><p>假设现在有两个自然数A和B，S是A^B的所有约数之和。</p><p>请你求出S mod 9901的值是多少。</p><h4 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h4><p>在一行中输入用空格隔开的两个整数A和B。</p><h4 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，代表S mod 9901的值。</p><p>分析：下图为需要用到的公式。</p><p><img src="/2019/06/02/递归专项/F:%5CANJINYANG17%5C%E5%AD%A6%E4%B9%A0%5C%E6%97%A5%E8%AE%B0%5CACM%E8%AE%AD%E7%BB%83%E6%97%A5%E8%AE%B0%5C%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98%E7%9B%B8%E5%85%B3.png" alt="数学问题相关"></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">9901</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quickpower</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a%=mod;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> k)</span><span class="comment">//这里是难点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k%<span class="number">2</span>==<span class="number">0</span>)<span class="keyword">return</span> (p%mod*sum(p,k<span class="number">-1</span>)%mod+<span class="number">1</span>)%mod;</span><br><span class="line">    <span class="keyword">return</span> (quickpower(p,k/<span class="number">2</span>+<span class="number">1</span>)+<span class="number">1</span>)%mod*sum(p,k/<span class="number">2</span>)%mod;<span class="comment">//这里不取余会有错误？错误数据50000000 50000000答案5531</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=a;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;    </span><br><span class="line">        <span class="keyword">while</span>(a%i==<span class="number">0</span>)<span class="comment">//错写成a%i!=0</span></span><br><span class="line">        &#123;</span><br><span class="line">            a/=i;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k)ans=ans*sum(i,k*b)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>)ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分形之城"><a href="#分形之城" class="headerlink" title="分形之城"></a>分形之城</h2><p>城市的规划在城市建设中是个大问题。</p><p>不幸的是，很多城市在开始建设的时候并没有很好的规划，城市规模扩大之后规划不合理的问题就开始显现。</p><p>而这座名为 Fractal 的城市设想了这样的一个规划方案，如下图所示：</p><p><img src="https://www.acwing.com/media/article/image/2019/01/07/19_1ac25efe11-city.png" alt="city.png"></p><p>当城区规模扩大之后，Fractal 的解决方案是把和原来城区结构一样的区域按照图中的方式建设在城市周围，提升城市的等级。</p><p>对于任意等级的城市，我们把正方形街区从左上角开始按照道路标号。</p><p>虽然这个方案很烂，Fractal 规划部门的人员还是想知道，如果城市发展到了等级 N，编号为 A 和 B 的两个街区的直线距离是多少。</p><p>街区的距离指的是街区的中心点之间的距离，每个街区都是边长为 10 米的正方形。</p><h4 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入正整数n，表示测试数据的数目。</p><p>以下n行，输入n组测试数据，每组一行。</p><p>每组数据包括三个整数 N,A,B, 表示城市等级以及两个街区的编号，整数之间用空格隔开。</p><h4 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h4><p>一共输出n行数据，每行对应一组测试数据的输出结果，结果四舍五入到整数。</p><p>难点在于坐标转化。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,LL&gt; PLL;</span><br><span class="line"></span><br><span class="line"><span class="function">PLL <span class="title">calc</span><span class="params">(LL n,LL m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span>&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    LL len=<span class="number">1l</span>l&lt;&lt;n<span class="number">-1</span>,cnt=<span class="number">1l</span>l&lt;&lt;<span class="number">2</span>*n<span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">auto</span> pos=calc(n<span class="number">-1</span>,m%cnt);</span><br><span class="line">    <span class="keyword">auto</span> x=pos.first,y=pos.second;</span><br><span class="line">    <span class="keyword">auto</span> z=m/cnt;</span><br><span class="line">    <span class="keyword">if</span>(z==<span class="number">0</span>) <span class="keyword">return</span> &#123;y,x&#125;;</span><br><span class="line">    <span class="keyword">if</span>(z==<span class="number">1</span>) <span class="keyword">return</span> &#123;x,y+len&#125;;</span><br><span class="line">    <span class="keyword">if</span>(z==<span class="number">2</span>) <span class="keyword">return</span> &#123;x+len,y+len&#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">2</span>*len<span class="number">-1</span>-y,len<span class="number">-1</span>-x&#125;;<span class="comment">//迷之减一，通过画图发现上面的+len确实比这里需要平移的距离长一小节</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        LL n,a,b;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">auto</span> ac=calc(n,a<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">auto</span> bc=calc(n,b<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">double</span> x=ac.first-bc.first,y=ac.second-bc.second;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.0lf\n"</span>,<span class="built_in">sqrt</span>(x*x+y*y)*<span class="number">10</span>);<span class="comment">//四舍五入保留整数.0lf，sqrt里多写了个*号导致没过</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;递归实现指数型枚举&quot;&gt;&lt;a href=&quot;#递归实现指数型枚举&quot; class=&quot;headerlink&quot; title=&quot;递归实现指数型枚举&quot;&gt;&lt;/a&gt;递归实现指数型枚举&lt;/h2&gt;&lt;p&gt;从 1~n 这 n 个整数中随机选取任意多个，输出所有可能的选择方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://www.anjinyang.top/tags/algorithm/"/>
    
      <category term="基础算法" scheme="https://www.anjinyang.top/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://www.anjinyang.top/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="递推" scheme="https://www.anjinyang.top/tags/%E9%80%92%E6%8E%A8/"/>
    
  </entry>
  
  <entry>
    <title>贪心专题</title>
    <link href="https://www.anjinyang.top/2019/06/02/%E8%B4%AA%E5%BF%83/"/>
    <id>https://www.anjinyang.top/2019/06/02/贪心/</id>
    <published>2019-06-02T01:43:01.000Z</published>
    <updated>2019-10-16T03:05:07.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="贪心专题"><a href="#贪心专题" class="headerlink" title="贪心专题"></a>贪心专题</h1><h3 id="防晒霜"><a href="#防晒霜" class="headerlink" title="防晒霜"></a>防晒霜</h3><p>有C头奶牛进行日光浴，第i头奶牛需要minSPF[i]到maxSPF[i]单位强度之间的阳光。 <a id="more"></a> </p><p>每头奶牛在日光浴前必须涂防晒霜，防晒霜有L种，涂上第i种之后，身体接收到的阳光强度就会稳定为SPF[i]，第i种防晒霜有cover[i]瓶。</p><p>求最多可以满足多少头奶牛进行日光浴。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入整数C和L。</p><p>接下来的C行，按次序每行输入一头牛的minSPF和maxSPF值,即第i行输入minSPF[i]和maxSPF[i]。</p><p>再接下来的L行，按次序每行输入一种防晒霜的SPF和cover值,即第i行输入SPF[i]和cover[i]。</p><p>每行的数据之间用空格隔开。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，代表最多可以满足奶牛日光浴的奶牛数目。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤C,L≤2500，<br>1≤minSPF≤maxSPF≤1000,<br>1≤SPF≤1000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">3 10</span><br><span class="line">2 5</span><br><span class="line">1 5</span><br><span class="line">6 2</span><br><span class="line">4 1</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>分析：二分图的匹配问题。匈牙利算法。当前匹配为最大匹配的条件是不存在增广路径。平衡树set或者map。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2505</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cow</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> minn,maxn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cover[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cow</span> <span class="title">cows</span>[<span class="title">N</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(cow a,cow b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.minn==b.minn)<span class="keyword">return</span> a.maxn&gt;b.maxn;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.minn&gt;b.minn;<span class="comment">//按照minspf由大到小排序是正解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c,l;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;c&gt;&gt;l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;cows[i].minn&gt;&gt;cows[i].maxn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> spf,temp;<span class="comment">// 数据中存在spf值相同的防晒霜</span></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;spf&gt;&gt;temp;</span><br><span class="line"></span><br><span class="line">        cover[spf]+=temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(cows,cows+c,cmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> temp=cows[i].maxn;temp&gt;=cows[i].minn;temp--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cover[temp]!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                cover[temp]--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2505</span>;</span><br><span class="line"><span class="keyword">int</span> c,l;<span class="comment">//接下来用什么存储牛和防晒霜的数据</span></span><br><span class="line">PII cows[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;c&gt;&gt;l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c;i++)<span class="built_in">cin</span>&gt;&gt;cows[i].first&gt;&gt;cows[i].second;</span><br><span class="line">    sort(cows,cows+c);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; spfs;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> spf,cover;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;spf&gt;&gt;cover;</span><br><span class="line">        spfs[spf]+=cover;<span class="comment">//可能同一个spf给多次</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    spfs[<span class="number">0</span>]=spfs[<span class="number">1001</span>]=c;<span class="comment">//二分查找返回大于等于某个数的第一个地址，所以要在两边加上c???</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=c<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> cow=cows[i];</span><br><span class="line">        <span class="keyword">auto</span> it=spfs.upper_bound(cow.second);<span class="comment">////lower返回大于等于,upper返回大于，再减减就可以得到小于等于某个数的最大的数</span></span><br><span class="line">        it--;</span><br><span class="line">        <span class="keyword">if</span>(it-&gt;first&gt;=cow.first &amp;&amp; it-&gt;first&lt;=cow.second)</span><br><span class="line">        &#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">if</span>(-- it-&gt;second==<span class="number">0</span>)<span class="comment">//it第一个关键字是spf第二个关键字是cover</span></span><br><span class="line">                spfs.erase(it);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="畜栏预定"><a href="#畜栏预定" class="headerlink" title="畜栏预定"></a>畜栏预定</h3><p>有N头牛在畜栏中吃草。</p><p>每个畜栏在同一时间段只能提供给一头牛吃草，所以可能会需要多个畜栏。</p><p>给定N头牛和每头牛开始吃草的时间A以及结束吃草的时间B，每头牛在[A,B]这一时间段内都会一直吃草。</p><p>当两头牛的吃草区间存在交集时（<strong>包括端点</strong>），这两头牛不能被安排在同一个畜栏吃草。</p><p>求需要的最小畜栏数目和每头牛对应的畜栏方案。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第1行：输入一个整数N。</p><p>第2-N+1行：第i+1行输入第i头牛的开始吃草时间A以及结束吃草时间B，数之间用空格隔开。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>第1行：输入一个整数，代表所需最小畜栏数。</p><p>第2..N+1行：第i+1行输入第i头牛被安排到的畜栏编号，编号从1开始，只要方案合法即可。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤N≤50000,<br>1≤A,B≤1000000</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 10</span><br><span class="line">2 4</span><br><span class="line">3 6</span><br><span class="line">5 8</span><br><span class="line">4 7</span><br></pre></td></tr></table></figure><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e4</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">pair&lt;P,<span class="keyword">int</span>&gt; cows[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> id[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;cows[i].first.first&gt;&gt;cows[i].first.second;</span><br><span class="line">        cows[i].second=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(cows,cows+n);<span class="comment">//这里怎么排序：直接排序为什么？猜想这里排序直接对cows[i].first.first进行排序 解释：这里pair排序先根据first.first然后first.second 最后是second</span></span><br><span class="line"></span><br><span class="line">    priority_queue&lt;P,<span class="built_in">vector</span>&lt;P&gt;,greater&lt;P&gt; &gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q.empty()||q.top().first&gt;=cows[i].first.first)<span class="comment">//判断条件应该是前一个的结束时间是否大于等于当前这个的开始时间</span></span><br><span class="line">        &#123;</span><br><span class="line">            id[cows[i].second]=q.size();</span><br><span class="line">            q.push(make_pair(cows[i].first.second,q.size()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            P stall=q.top();</span><br><span class="line">            q.pop();<span class="comment">//这里忘记了pop把替换掉的删除出去</span></span><br><span class="line">            stall.first=cows[i].first.second;</span><br><span class="line">            id[cows[i].second]=stall.second;</span><br><span class="line">            q.push(stall);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;q.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)<span class="built_in">cout</span>&lt;&lt;id[i]+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="雷达设备"><a href="#雷达设备" class="headerlink" title="雷达设备"></a>雷达设备</h3><p>假设海岸是一条无限长的直线，陆地位于海岸的一侧，海洋位于另外一侧。</p><p>每个小岛都位于海洋一侧的某个点上。</p><p>雷达装置均位于海岸线上，且雷达的监测范围为d，当小岛与某雷达的距离不超过d时，该小岛可以被雷达覆盖。</p><p>我们使用笛卡尔坐标系，定义海岸线为x轴，海的一侧在x轴上方，陆地一侧在x轴下方。</p><p>现在给出每个小岛的具体坐标以及雷达的检测范围，请你求出能够使所有小岛都被雷达覆盖所需的最小雷达数目。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入两个整数n和d，分别代表小岛数目和雷达检测范围。</p><p>接下来n行，每行输入两个整数，分别代表小岛的x，y轴坐标。</p><p>同一行数据之间用空格隔开。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，代表所需的最小雷达数目，若没有解决方案则所需数目输出“-1”。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤10001≤n≤1000</p><h4 id="输入样例：-2"><a href="#输入样例：-2" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 2</span><br><span class="line">-3 1</span><br><span class="line">2 1</span><br></pre></td></tr></table></figure><h4 id="输出样例：-2"><a href="#输出样例：-2" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>分析：通过以某个岛为圆心d为半径做圆可将二维问题转化为一维的区间问题。按终点由小到大排序，从头遍历，如果当前区间不包含最后一个选择点，就在当前区间右端创建一个新的选择点。因为只有当前区间和最后一个选择点没有交集时才会选择一个新的点，所以所选出的点以d为半径做圆，所有的圆都不会相交。因此最少选择m个点，最优解一定大于等于m，但是我们找到了答案为m的解法，所以答案就是m。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt; PDD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>  N=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-6</span>,inf=<span class="number">1e10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,r;</span><br><span class="line">PDD segs[N];</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span>(y&gt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            flag=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> len=<span class="built_in">sqrt</span>(r*r-y*y);</span><br><span class="line">        segs[i]=&#123;x+len,x-len&#125;;<span class="comment">//pair没有push直接赋值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> last=-inf;</span><br><span class="line">    <span class="keyword">if</span>(!flag)<span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sort(segs,segs+n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(segs[i].second&gt;last+eps)</span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                last=segs[i].first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="国王游戏"><a href="#国王游戏" class="headerlink" title="国王游戏"></a>国王游戏</h3><p>恰逢 H 国国庆,国王邀请 n 位大臣来玩一个有奖游戏。</p><p>首先,他让每个大臣在左、右手上面分别写下一个整数,国王自己也在左、右手上各写一个整数。</p><p>然后,让这 n 位大臣排成一排,国王站在队伍的最前面。</p><p>排好队后,所有的大臣都会获得国王奖赏的若干金币,每位大臣获得的金币数分别是:</p><p>排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数,然后向下取整得到的结果。</p><p>国王不希望某一个大臣获得特别多的奖赏,所以他想请你帮他重新安排一下队伍的顺序,使得获得奖赏最多的大臣,所获奖赏尽可能的少。</p><p>注意,国王的位置始终在队伍的最前面。</p><h4 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含一个整数 n,表示大臣的人数。</p><p>第二行包含两个整数 a 和 b,之间用一个空格隔开,分别表示国王左手和右手上的整数。</p><p>接下来 n 行,每行包含两个整数 a 和 b,之间用一个空格隔开,分别表示每个大臣左手和右手上的整数。</p><h4 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出只有一行,包含一个整数,表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。</p><h4 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤1000<br>0&lt;a,b&lt;10000</p><h4 id="输入样例：-3"><a href="#输入样例：-3" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 1</span><br><span class="line">2 3</span><br><span class="line">7 4</span><br><span class="line">4 6</span><br></pre></td></tr></table></figure><h4 id="输出样例：-3"><a href="#输出样例：-3" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>分析：从小到大排序即可。证明可以只看两个数，计算一下发现，把一对逆序的数交换后，最后的奖励一定不会增加（趋向于减小，只有当a[i]=1的时候回相等，否则就会减少），而且不会改变其他的奖励。所以只要不是排好序的就有可能变得更小，所以证得做法正确。此题难点在于高精度（这道题涉及到了高精度数*一个数，高精度数/一个数，没有涉及到高精度之间的运算）。</p><p>高精度计算vector版本:vector<int> vec(num1,num2); 表示初始化vec中有num1个num2。存取用小位在前高位在后。</int></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;贪心专题&quot;&gt;&lt;a href=&quot;#贪心专题&quot; class=&quot;headerlink&quot; title=&quot;贪心专题&quot;&gt;&lt;/a&gt;贪心专题&lt;/h1&gt;&lt;h3 id=&quot;防晒霜&quot;&gt;&lt;a href=&quot;#防晒霜&quot; class=&quot;headerlink&quot; title=&quot;防晒霜&quot;&gt;&lt;/a&gt;防晒霜&lt;/h3&gt;&lt;p&gt;有C头奶牛进行日光浴，第i头奶牛需要minSPF[i]到maxSPF[i]单位强度之间的阳光。&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://www.anjinyang.top/tags/algorithm/"/>
    
      <category term="基础算法" scheme="https://www.anjinyang.top/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
      <category term="贪心" scheme="https://www.anjinyang.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>最短Hamilton路径</title>
    <link href="https://www.anjinyang.top/2019/06/02/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B9%8B%E6%9C%80%E7%9F%ADHamilton%E8%B7%AF%E5%BE%84/"/>
    <id>https://www.anjinyang.top/2019/06/02/状态压缩位运算之最短Hamilton路径/</id>
    <published>2019-06-02T01:43:01.000Z</published>
    <updated>2019-10-16T03:05:35.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最短Hamilton路径"><a href="#最短Hamilton路径" class="headerlink" title="最短Hamilton路径"></a>最短Hamilton路径</h1><p>给定一张 n 个点的带权无向图，点从 0~n-1 标号，求起点 0 到终点 n-1 的最短Hamilton路径。 Hamilton路径的定义是从 0 到 n-1 不重不漏地经过每个点恰好一次。 <a id="more"></a> </p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入整数n。</p><p>接下来n行每行n个整数，其中第i行第j个整数表示点i到j的距离（记为a[i,j]）。</p><p>对于任意的x,y,z，数据保证 a[x,x]=0，a[x,y]=a[y,x] 并且 a[x,y]+a[y,z]&gt;=a[x,z]。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最短Hamilton路径的长度。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤20,0≤a[i,j]≤10^7</p><p>分析都在代码里了。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二进制0和1表示存在不存在，状态压缩</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">20</span>,M=<span class="number">1</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> f[M][N],weight[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;weight[i][j];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> f);<span class="comment">//(初始化为正无穷)地址f，大小sizeof f,初始化为0x3f</span></span><br><span class="line">    </span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//已经走过的点有0，现在在0位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span>(i&gt;&gt;j&amp;<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">                    <span class="keyword">if</span>(i-(<span class="number">1</span>&lt;&lt;j)&gt;&gt;k&amp;<span class="number">1</span>)</span><br><span class="line">                        f[i][j]=min(f[i][j],f[i-(<span class="number">1</span>&lt;&lt;j)][k]+weight[k][j]);<span class="comment">//f[i][j]=min(f[i][j],f[这里第一次写错了][k]+weight[k][j])</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>][n<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//for中定义的i在这里不能用所以写成1&lt;&lt;n，最后还忘了加括号，减号优先级高于移位运算符</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;最短Hamilton路径&quot;&gt;&lt;a href=&quot;#最短Hamilton路径&quot; class=&quot;headerlink&quot; title=&quot;最短Hamilton路径&quot;&gt;&lt;/a&gt;最短Hamilton路径&lt;/h1&gt;&lt;p&gt;给定一张 n 个点的带权无向图，点从 0~n-1 标号，求起点 0 到终点 n-1 的最短Hamilton路径。 Hamilton路径的定义是从 0 到 n-1 不重不漏地经过每个点恰好一次。&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://www.anjinyang.top/tags/algorithm/"/>
    
      <category term="状态压缩" scheme="https://www.anjinyang.top/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
      <category term="递归" scheme="https://www.anjinyang.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>web小测复习</title>
    <link href="https://www.anjinyang.top/2019/04/14/web%E5%B0%8F%E6%B5%8B%E5%A4%8D%E4%B9%A0/"/>
    <id>https://www.anjinyang.top/2019/04/14/web小测复习/</id>
    <published>2019-04-13T16:00:00.000Z</published>
    <updated>2019-10-16T03:05:45.458Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2019-4-13web小测复习"><a href="#2019-4-13web小测复习" class="headerlink" title="2019.4.13web小测复习"></a>2019.4.13web小测复习</h3><h4 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h4><ul><li><p>web相关概念</p></li><li><p>了解web领域</p></li><li><p>B/S架构</p></li><li><p>学习方法</p><a id="more"></a> </li></ul><p>万维网：（亦作“Web”、“WWW”、全称为“World  Wide Web”），是一个由许多互相链接的超文本组成的系统，通过互联网访问。</p><p>URL</p><ul><li>Uniform Resource Locator 统一资源定位符</li><li>组成部分：协议、服务器地址（域名）、资源路径</li></ul><p>B/S架构（Browser/Server）</p><ul><li>通过浏览器访问的网络应用程序。</li><li>典型应用：<ul><li>师大官网、网页版微博、网页版京东 …</li></ul></li><li>特点：无缝升级、客户端免维护；不能直接使用客户端硬件资源，用户体验单一</li></ul><p>C/S架构（Client/Server）</p><ul><li>通过客户端应用软件访问的网络应用程序。</li><li>典型应用：<ul><li>淘宝、QQ、微信 …</li></ul></li><li>特点：能直接使用客户端硬件资源；需要安装特定客户端程序、针对不同平台开发不同版本、升级应用须重新安装。</li></ul><p><img src="/2019/04/14/web小测复习/img/article/1555121152235.png" alt></p><h4 id="第二章-html基础"><a href="#第二章-html基础" class="headerlink" title="第二章 html基础"></a>第二章 html基础</h4><ul><li><p>理解网页文件</p></li><li><p>掌握html语法基础</p></li><li><p>html常用标签</p></li></ul><p>什么是网页？什么是网页文件？</p><ul><li><p>网页是构成网站的基本元素，是承载各种网站应用的平台，实质就是一个网页文件。</p></li><li><p>网页文件就是文本文件，扩展名为 .html 或 .htm，文件内容为 HTML 代码和文本内容</p></li></ul><p>访问网页的过程？</p><ol><li>通过输入网址（[URL][Uniform Resource Locator 统一资源定位符]）指定要访问的网页</li><li>请求：向服务器（server）发送请求，把XXX网页文件传送给我</li><li>响应：服务器发出响应，把XXX网页文件传送给你</li><li>浏览器(browser)“解释”网页文件，呈现出网页</li></ol><p>单双标签作用？</p><ul><li>单标签：在开始标签中进行关闭，无需表达范围，仅在标签出现处有效</li><li>双标签：由“开始标签”和“结束标签”两部分构成。必须成对使用。 代表标签作用范围</li></ul><p>HTML:Hyper Text Markuo Language</p><ul><li>超文本标记语言</li><li>HTML不是编程语言，是一种标记语言</li><li>标记语言是一套标记标签，HTML用标记标签来描述网页</li><li>三个要点：词汇、语法、语义</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span>:HTML文档声明</span><br></pre></td></tr></table></figure><p>用法：放在文件开头 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span>：HTML（网页）文件开始及结束</span><br></pre></td></tr></table></figure><p>用法：成对出现、分别位于文件的开始和结束位置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span>：指明网页文件的头部</span><br></pre></td></tr></table></figure><p>用法：成对出现、嵌套于 html 标签内、位于 body 标签之上</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> /&gt;</span>：定义页面有关信息，如页面编码、关键词、页面描述</span><br></pre></td></tr></table></figure><p>用法：单标签，必须在 head 标签内、利用属性值进行设置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span> <span class="tag">&lt;/<span class="name">title</span>&gt;</span>：在浏览器标题栏显示的文档标题</span><br></pre></td></tr></table></figure><p>用法：成对出现、嵌套于 head 标签内</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span>：指明网页文件体部</span><br></pre></td></tr></table></figure><p>用法：成对出现、嵌套于 html 标签内、位于 head 标签之下</p><p>HTML 元素：从开始标签到结束标签的所有代码。</p><p>书写规范</p><ul><li>标签可以嵌套的，但先后书序必须保持一致</li><li>标签对大小写不敏感，同意建议小写</li></ul><p>标签属性</p><ul><li>书写形式： NAME = “VALUE”</li><li>位置：开始标签</li><li>不同标签有不同属性</li></ul><p>标题标签：h1-h6</p><p>段落标签：p ，p元素会自动在其前后创建一些空白</p><p>图片标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>属性：</p><ul><li>路径 src:相对路径、绝对路径</li><li>alt:当图片无法加载显示的替换文本</li></ul><p>绝对路径：从盘符开始的完整路径。</p><p>相对路径：指相对当前文件或目录的路径。</p><p>相对路径规则：</p><ul><li>图片和网页在同级目录     src=”<strong>./</strong>图片名”</li><li>图片在网页的下一级目录  src=”目录名称<strong>/</strong>图片名”</li><li>图片在网页的上一级目录 src=”<strong>../</strong>图片名”</li></ul><p>超链接</p><ul><li><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>……<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>href：必选属性，规定连接目标</p></li><li><p>target:_blank新窗口打开， _self当前窗口打开（默认）</p></li></ul><p>无需列表和有序列表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">无序列表使用<span class="tag">&lt;<span class="name">ul</span>&gt;</span> 标签， 每个列表项使用 <span class="tag">&lt;<span class="name">li</span>&gt;</span>标签</span><br><span class="line">有序列表使用 <span class="tag">&lt;<span class="name">ol</span>&gt;</span> 标签，每个列表项使用 <span class="tag">&lt;<span class="name">li</span>&gt;</span>标签</span><br></pre></td></tr></table></figure><p>注意事项</p><ul><li>文件的扩展名要以 .html 或者 .htm 结束。</li><li>文件名由英文字母、数字或下划线组成。</li><li>文件名中不要包含特殊符号，比如空格、$ 等，不使用中文。</li></ul><h4 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h4><ul><li><p>表格</p></li><li><p>表单</p></li></ul><h5 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">""</span>&gt;</span> <span class="tag">&lt;/<span class="name">table</span>&gt;</span>定义一个表格</span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span> 定义表格中一行，嵌套于table内</span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span> <span class="tag">&lt;/<span class="name">th</span>&gt;</span>定义表头，嵌套于tr内</span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">td</span>&gt;</span>定义单元格，嵌套于tr内</span><br></pre></td></tr></table></figure><p>相关属性：</p><ul><li>border：        表格边框的宽度（pixels）</li><li>bordercolor：表格边框的颜色</li><li>background：表格背景图</li><li>bgcolor：       表格背景颜色</li><li>cellpadding :  单元边沿与其内容之间的距离（pixels）</li><li>cellspacing :   单元格之间的空白（pixels）</li><li>width :      规定表格元素的宽度（pixels或%）</li><li>height :     规定表格元素的高度（pixels或%）</li><li>align：      表格的对齐方式（left  center  right）</li></ul><p><img src="/2019/04/14/web小测复习/img/article/cell.png" alt="cell"></p><p>单元格合并：</p><ul><li>colspan:某行列合并</li><li>rowspan:某列行合并</li></ul><h5 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h5><p>表单是一个包含表单元素的区域。表单元素是允许用户在表单中输入信息的元素。（比如：文本框、下拉列表、单选框、复选框等等）</p><p>其作用是从访问网站的用户那里获得信息，是用户向服务器传输数据的接口。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">method</span>=<span class="string">""</span>&gt;</span> <span class="tag">&lt;/<span class="name">form</span>&gt;</span>定义一个表单</span><br></pre></td></tr></table></figure><p>相关属性：<br>action：   规定向何处发送提交的表单数据。值：URL<br>method：规定以何种方式将表单数据传送到服务器。值：get/post</p><p>Get</p><ul><li>URL 改变，在URL 里显示 HTML Form 参数的 name/value 值。</li><li>只适合有少量参数的 HTML Form，因为 URL 长度有字符限制，不能无限长。</li><li>涉及安全性的信息，比如用户密码，不能用 get，因为会在 URL 上显示，不安全。</li></ul><p>Post</p><ul><li>URL 不改变，不在 URL 里显示 HTML Form 的数据。</li><li>Form 提交的信息没有长度限制。</li><li>涉及安全性的信息，如用户密码，应采用 post 方式。</li></ul><p>表单控件input标签</p><p>文本框：当用户要在表单中输入字母、数字等时，用到文本框</p><ul><li>type：当type = “text”时，输入框为文本输入框。</li><li>name：为输入框命名，以备后台程序使用。</li><li>value：为输入框设置默认值。(一般起到提示作用)</li></ul><p>密码框</p><ul><li>type=”password”</li></ul><p>单选框</p><ul><li>type=”radio” 添加checked默认选中</li></ul><p>复选框</p><ul><li>type=”checkbox”添加checked默认选中</li></ul><p>文件控件</p><ul><li>type=”file”</li></ul><p>按钮</p><ul><li>提交按钮 type=”submit”</li><li>重置按钮 type=”reset”</li><li>普通按钮 type=”button”</li></ul><p>一组单选框或一组多选框中每个input标签的name属性为什么必须要有相同取值？</p><p>同组单选框/复选框name属性值必须相同，是为了将其归为同一组，提交数据时作为一组数据进行提交。这样同组单选框才可以起到单选作用，复选框可识别为同一问题的多个选择。</p><p>表单控件<textarea>多行文本域</textarea></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">rows</span>=<span class="string">""</span> <span class="attr">cols</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>相关属性</p><p>rows：规定文本区可见行数</p><p>cols：规定文本区可见列数</p><p>表单控件<select>下拉列表</select></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>lable标签</p><p><label for="控件id名称"> 用户名：</label><br><input type="text" id="id名称"></p><p>当鼠标点击“用户名：”时，所关联的控件会获得焦点。</p><ul><li>label 元素不会向用户呈现任何特殊效果，它只是增加了用户体验。</li><li>点击 label 元素内文本，就会触发此控件。即当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</li></ul><p>热区相关代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span> = <span class="string">"planets.jpg"</span> <span class="attr">usemap</span> = <span class="string">"#planetmap"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span> = <span class="string">"planetmap"</span> <span class="attr">id</span> = <span class="string">"planetmap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span> = <span class="string">"circle"</span> <span class="attr">coords</span> = <span class="string">"180,139,14"</span> <span class="attr">href</span> = <span class="string">"venus.html"</span> <span class="attr">alt</span> = <span class="string">"Venus"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span> = <span class="string">"rect"</span>  <span class="attr">coords</span> = <span class="string">"0,0,110,260"</span> <span class="attr">href</span> = <span class="string">"sun.html"</span> <span class="attr">alt</span> = <span class="string">"Sun"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span>   <span class="attr">src</span>=<span class="string">""</span>  <span class="attr">usemap</span>=<span class="string">"**#**名称"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span>&gt;</span>  name="名称” id="名称"&gt;<span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure><p>map 中的 id 属性和 name 属性设置为相同，与 img /标签的usemap 属性匹配，创建图像与映射之间的联系。</p><p><strong><area></strong> —— 定义图像映射中的区域</p><ul><li>alt：替代文本</li><li>href：该区域的链接地址</li><li>shape：该区域的形状（rect：矩形  circle：圆形  poly：多边形）</li><li>coords：该区域在原始图片上的坐标值</li></ul><p>内联框架</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>相关属性</p><ul><li>src：文件的路径</li><li>width、height：“内联框架”区域的宽与高</li><li>name：框架的名字，用来识别框架</li><li>frameBorder：设置是否显示框架的边框，值为 1 或者 0</li><li>scrolling：当 src 的指定的HTML文件在指定的区域显示不完时，滚动选项：no（不出现滚动） /  yes（显示滚动）  /  auto（自动出现滚动条）</li></ul><h4 id="第四章-CSS开发基础"><a href="#第四章-CSS开发基础" class="headerlink" title="第四章 CSS开发基础"></a>第四章 CSS开发基础</h4><p><strong>CSS</strong> 是 <strong>Cascading Style Sheet</strong> 的缩写。译作「层叠<strong>样式表</strong>」。</p><p>CSS 是用于(增强)控制网页样式并允许将样式与网页内容<strong>分离</strong>的一种样式表语言。</p><p>CSS代码是由一条条语句构成，而每一条语句的结构，都基本相同</p><ul><li>选择器 {属性：属性值；属性：属性值;……}</li></ul><p>三类选择器</p><ul><li>标签选择器</li><li>类选择器</li><li>id选择器</li></ul><h6 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h6><p>直接以某类标签为选择器后加{属性：属性值；}</p><ol><li>标签选择器在什么情况下使用？<ul><li>控制某一类标签时</li></ul></li><li>标签选择器的优势？<ul><li>简便快速</li></ul></li><li>标签选择器的劣势？<ul><li>这类标签在需要区分的时候无法区分</li></ul></li></ol><h6 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h6><p>以 . 开头定义的选择器，影响所有以class属性引用该类的标签样式。类名的第一个字符不能使用数字和特殊字符。</p><h6 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h6><p>以 # 开头定义的选择器，影响以id属性引用该选择符的标签样式，id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。同一id 属性值只能在 HTML 文档中出现一次。</p><p>从内容中抽离出来的 CSS 样式，应如何与 HTML 内容进行整合使之生效呢？</p><ul><li>行内样式：标签内通过 style 属性添加样式。（style=”属性：属性值; “）用途：指定网页中个别元素的显示效果。不符合样式与内容分离原则，不推荐使用。</li><li>页内样式:在 head 部分的 style 标签内添加样式。用途：对页面中某些标签或元素设置样式风格。控制当前页面样式，维护较困难。</li><li>外部样式：引用外部建立的 .css 文件。用途：可同时控制多个页面。适用于各类大型网站，可用性最强，推荐使用。</li></ul><p>样式优先级：</p><ul><li>ID选择器 &gt; 类选择器 &gt; 标签选择器</li><li>行内样式 &gt; 页内样式 &gt; 外部样式</li><li>就近原则，距离元素最近的样式优先级最高</li></ul><p>lCSS 样式的叠加</p><ul><li>多个样式，在同一内容上共同实现，叫做 CSS 样式的叠加。</li></ul><p>lCSS 样式的可继承性</p><ul><li>文档中的某些元素，将沿用为其父元素所设想置的样式，这种特点叫做 CSS样式的可继承性。</li></ul><p>CSS注释方法：/* */</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;2019-4-13web小测复习&quot;&gt;&lt;a href=&quot;#2019-4-13web小测复习&quot; class=&quot;headerlink&quot; title=&quot;2019.4.13web小测复习&quot;&gt;&lt;/a&gt;2019.4.13web小测复习&lt;/h3&gt;&lt;h4 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;web相关概念&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;了解web领域&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;B/S架构&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;学习方法&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="html" scheme="https://www.anjinyang.top/tags/html/"/>
    
      <category term="CSS" scheme="https://www.anjinyang.top/tags/CSS/"/>
    
      <category term="web" scheme="https://www.anjinyang.top/tags/web/"/>
    
      <category term="计算机基础知识" scheme="https://www.anjinyang.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
</feed>
